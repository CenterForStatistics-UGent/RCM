#' A function to estimate the taxon-wise response functions non-parametrically, and return their fitted values
#'
#' @param sampleScore a vector of length n with environmental scores
#' @param muMarg the offset matrix
#' @param X the n-by-p data matrix
#' @param psi the importance parameter
#' @param ncols an integer, the number of columns of X
#' @param thetas a vector of length p with dispersion parameters
#' @param n an integer, the number of samples
#' @param coefInit a 2-by-p matrix with current taxon-wise parameter estimates
#' @param coefInitOverall a vector of length 2 with current overall parameters
#' @param dfSpline a scalar, the degrees of freedom for the smoothing spline.
#' @param vgamMaxit Maximal number of iterations in the fitting of the GAM model
#' @param degree The degree if the parametric fit if the VGAM fit fails
#' @param verbose a boolean, should number of failed fits be reported
#' @param ... further arguments, passed on to the VGAM:::vgam() function
#'
#' The negative binomial likelihood is still maximized, but now the response function is a non-parametric one. To avoid a perfect fit and overly flexible functions, we enforce smoothness restrictions. In practice we use a generalized additive model (GAM), i.e. with splines.  The same fitting procedure is carried out ignoring species labels. We do not normalize the parameters related to the splines: the psis can be calculated afterwards.
#'
#' @return A list with components
#' \item{taxonWiseFitted}{A n-by-p matrix of fitted valuesof the response curves per taxon at the observed values of the environmental scores}
#' \item{taxonCoef}{The fitted coefficients of the sample-wise response curves}
#' \item{overallFitted}{The fitted values of all taxa combined}
#' \item{taxonWiseFits}{A list of length p of normalized response curves of all the taxa. This may be useful to investigate the shape of the response function through plots.}
#' \item{taxonWise}{The taxonwise response function}
#'
#' @importFrom MASS negative.binomial
estNPresp = function(sampleScore, muMarg, X, psi, ncols, thetas, n, coefInit, coefInitOverall, dfSpline, vgamMaxit, degree, verbose,...){
  logMu = log(muMarg)
  MM = getModelMat(sampleScore, degree) #The model matrix for the parametric fit
    taxonWise = lapply(seq_len(ncols), function(i){
    df = data.frame(x = X[,i], sampleScore = sampleScore, logMu = log(muMarg[,i])) #Going through a dataframe slows things down, so ideally we should appeal directly to the vgam.fit function
      tmp = try(suppressWarnings(vgam.edit(data = df,x ~ s(sampleScore, df = dfSpline), psi = psi, offset = logMu, family = negbinomial.size(lmu = "loge", size = thetas[i]), coefstart = coefInit[[i]], maxit = vgamMaxit,...)), silent = TRUE)
    class = "vgam"
    if(class(tmp)=="try-error") { #If this fails turn to parametric fit
      warning("GAM would not fit, turned to parametric fit of degree ", degree, "!")
      tmp = try(nleqslv(fn =  dNBllcolNP, x = if(length(coefInit[[i]])==2) rep(1e-4, degree+1) else coefInit[[i]], X = X[,i], reg = MM, theta = thetas[i], muMarg = muMarg[,i], jac = NBjacobianColNP)$x)
      class = "glm"
    }
    if(class(tmp)[[1]]=="try-error") {
      warning("GLM would not fit either, returning independence model! ")
    tmp = numeric(degree+1)#If nothing will fit, stick to an independence model
    class = "independence"
    }
    list(fit = tmp, int = getInt(tmp, sampleScore = sampleScore, class = class), class = class)
  })
    names(taxonWise) = colnames(X)
    #Report failed fits
  sumFit = sum(sapply(taxonWise, function(x){x$class!="vgam"}))
  if(verbose && sumFit) warning("A total number of ",sumFit, " response functions did not converge! \n")
#Overall fit
  samRep = rep(sampleScore, ncols)
  overall = vgam.edit(c(X) ~ s(samRep, df = dfSpline), offset = c(logMu), family = negbinomial.size(lmu = "loge", size = rep(thetas, each = n)), coefstart = coefInitOverall, maxit = vgamMaxit, psi = psi,...)
#
#   rowMat = sapply(taxonWise, function(x){if(class(x$fit)=="vgam") predict(x$fit, type ="link") else MM %*% x$fit})
#   taxonCoef = lapply(taxonWise, function(x){if(class(x$fit)=="vgam") coef(x$fit) else x$fit})

  list(taxonWise = taxonWise, overall = list(fit = overall))
}


# n = 50
# size = 2
# psi = 1.45
# s = 10^rnorm(n,3)
# rel = 1e-3
# samScore = rnorm(50, sd = 0.2)
# mu = s*rel*exp(psi*samScore^3)
# y = rnbinom(n, mu = mu, size = size)
#
# df = data.frame(x = y, sampleScore = samScore, logMu = log(s*rel))
# vgamFit = RCM:::vgam.edit(data = df,x ~ s(sampleScore, df = dfSpline), psi = psi, offset = logMu, family = negbinomial.size(lmu = "loge", size = size), coefstart = NULL, maxit = 1e2)
# newSam = seq(-0.6, 0.4, length.out = 20)
# logMu = runif(20, 0.2,0.4)
# vgamPred = predict(vgamFit, newdata = data.frame(sampleScore = newSam, logMu = logMu), type ="link")
# spline = vgamFit@Bspline[[1]]
# coefVgam = coef(vgamFit)
# splinePred = cbind(1,newSam, predict(spline, x = newSam)$y) %*% c(coefVgam,1)
# plot(vgamPred,splinePred);abline(0,1)
# cbind(vgamPred,splinePred , splinePred+logMu)
#
#
# splinePredY = exp(splinePred*psi+ logMu)
# vgamPredY = c(predict(vgamFit, type = "response", newdata = data.frame(sampleScore = newSam, logMu = logMu)))
# plot(splinePredY, vgamPredY);abline(0,1)
# cbind(splinePredY, vgamPredY, exp(splinePred), exp(vgamPred))

