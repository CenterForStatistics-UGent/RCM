---
title: "A manual for the use of the RCM functions"
author: "Stijn Hawinkel"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: html_document
---

```{r check-install-load-packages, warning=FALSE, message=FALSE, echo=FALSE, purl=TRUE}
knitr::opts_chunk$set(cache = TRUE, autodep = TRUE,  warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE, tidy = TRUE, fig.width=9, fig.height=6, purl=TRUE, fig.show = "hold", cache.lazy = FALSE)
# The required package list:
reqpkg <- c("phyloseq","MASS", "parallel","nleqslv", "edgeR", "ggplot2", "alabama", "reshape2", "tensor", "locfit", "flux")
# Load all required packages and show version
for(i in reqpkg)
{
  print(i)
  print(packageVersion(i))
  library(i, quietly=TRUE, verbose=FALSE, warn.conflicts=FALSE, character.only=TRUE)
} 
par(pty="s", mar = c(8,2,4,2), cex.main = 0.9) #Make sure the biplots are square!
palStore = palette()
funFiles = dir("R")
for (i in funFiles) {source(file.path("R",i))} # Run all fitting functions
```

## Dataset

We use the _GlobalPatterns_ dataset that is built in to the phyloseq package. Since it is nly a tutorial, we limit the taxa to the 1000 most abundant ones.

```{r load Data}
data(GlobalPatterns)
GP = prune_taxa(GlobalPatterns, taxa = taxa_sums(GlobalPatterns) >= sort(taxa_sums(GlobalPatterns), decreasing = TRUE)[1000])
```

## Unconstrained RCM

The unconstrained RC(M) method represents all variability present in the data, regardless of covariate information. It should be used as a first step in an exploratory analysis. We fit a model with two dimensions, which takes a few minutes.

```{r fitUnconstrainedRCM}
GPrcmUnconstr2 = RCM(GP, k=2)
```

The runtime was `r round(GPrcmUnconstr2$runtime,1)` to be exact. We plot the result of this ordination in a biplot, beginning with the samples.

```{r plotUnconstrainedRCMsam}
plot(GPrcmUnconstr2, plotType = "samples")
```

Samples appear to cluster together in small groups. Note also that the plot is rectangular according to the values of the importance parameters $\psi$. In order to truthfully represent the distances between samples all axis must be on the same scale. We can add a colour code for the sample variables contained in the phyloseq object.

```{r plotUnconstrainedRCMsamCol}
plot(GPrcmUnconstr2, plotType = "samples", samColour = "SampleType")
```

It is clear that our RC(M) method separates the different sample types.

Next we plot only the species.

```{r plotUnconstrainedRCMspec}
plot(GPrcmUnconstr2, plotType = "species")
```

Finally we can combine both plots into an interpretable biplot, which is the default for unconstrained RC(M). To avoid overplotting we only show the taxa with the five most important departures from independence.

```{r plotUnconstrainedRCMall}
plot(GPrcmUnconstr2, taxNum = 5, samColour = "SampleType")
```

Samples are represented by dots, taxa by arrows. Both represent vectors with the origin as starting point.

Valid interpretatations are the following:

 - Samples (endpoints of sample vectors, the red dots) close together depart from independence in a similar way
 - The orthogonal projection of the taxon arrows on the sample arrows are proportional to the departure from independence of that taxon in that sample on the log scale, in the first two dimensions. For example OTU 142768 is less abundant than average in skin and soil samples, but more abundant in e.g. sediment samples.
 - The importance parameters $\psi$ shown for every axis reflect the relative importance of the dimensions
 
Distances between endpoints of taxon vectors are meaningless.

### Adding dimensions

Since the model is fitted dimension per dimension, we only have information on the first two dimension. If we want to add a third dimension, we do not have to start from scratch but can use the previously fitted model in two dimension as a starting point and additionally estimate the third dimension.

```{r addDimension}
GPrcmUnconstr3 = RCM(GP, prevFit = GPrcmUnconstr2, k = 3)
```

The total runtime for all dimensions combined was `r round(GPrcmUnconstr3$runtime,1)`. We can then plot any combination of two dimensions we want, e.g. the first and the third.

```{r plotAddedDimension}
plot(GPrcmUnconstr3, Dim = c(1,3), samColour = "SampleType")
```

The third dimension serves to separate freshwater from ocean samples, and remarkably also separates the soil samples. Note also that the third dimension gets a higher importance parameter than the second one.

## Constrained analysis

In this second step we look for the variability in the dataset explained by linear combinations of covariates that maximally separate the niches of the species. This should be done in a second step, and preferably only with variables that are believed to have an impact on the species' abundances. Here we only use the sample type as environmental variable.
In this analysis all covariates values of a sample are projected onto a single scalar, the environmental score of this sample. The projection vector is called the environmental gradient, the magnitude of its components reveals the importance of each variable. The taxon-wise response functions then describe how the logged mean abundance depends on the environmental score.

### Linear response functions

Even though these response functions may be too simplistic, they have the advantage of being easy to interpret (and plot).

```{r GPconstrLin}
GPrcmConstr2 = RCM(GP, k = 2, covariates = c("SampleType"))
```

This plot shows the environmental scores of the samples in 2D. No clusters are visible in the samples plot of the constrained analysis with linear response functions.

```{r plotCMETlin2, purl = FALSE}
plot(armpitRCMconstrLin, plotType = c("samples", "species"), numTax = 8)
```

The taxa that react most strongly to the environmental gradient are the Corynebacteria. The interpretation of this plot is the same as for the unconstrained case. Note however that the species scores are no longer centered at the origin. Each species' vector has its own origin, representing the value of the environmental score for which there is no departure from independence explained by the covariates.

Say we plot only the Corynebacteria for now

```{r plotCMETlin2cor, purl = FALSE}
plot(armpitRCMconstrLin, plotType = c("species"), taxRegExp = "Coryne", taxLabels = FALSE)
```

Most Corynebacteria point in bottom left direction. look at only Staphylococci.

```{r plotCMETlin2staph, purl = FALSE}
plot(armpitRCMconstrLin, plotType = c("species"), taxRegExp = "Staph", taxLabels = FALSE)
```

The staphylococci increase abundance as going ot the right

Let's look at the variables that matter for the environmental gradient.

```{r plotCMETlin3, purl = FALSE}
plot(armpitRCMconstrLin, plotType =c("variables", "species"), labSize = 3, varNum = 4)
```

Here the orthogonal projection of species vectors on variable vectors represents the sensitivity of this taxon to changes in this variable.

No variables stand out from the rest in terms of environmental gradient. We should try to fit a model with less covariates. Care should be taken when comparing the coefficients of continuous and dummy variables in this plot. E.g. the fact that "age" and "Milkproductsevery_few_days" are close together means that one standard deviation of age away from the average age has a similar effect as consuming milk products every few days. Note also that there is no reference level for the categorical variables, all levels are plotted.

To finish we also show the triplot, which unites all the information of the plot:

```{r plotCMETlin4, purl = FALSE}
plot(armpitRCMconstrLin, labSize = 2, varNum = 4)
```

In this case a bit overplotted. Samples and variable vectors cannot be related to one another.

```{r linDev, purl = FALSE, include = FALSE, eval = FALSE}
linDev = getDeviance(armpitRCMconstrLin)
plot(armpitRCMconstrLin, plotType = c("samples"), samColour = rowMeans(linDev), colLegend = "Deviance")
```

```{r linDev2, purl = FALSE, eval = FALSE}
plot(armpitRCMconstrLin, plotType = c("species"), arrowCol = colMeans(linDev), colLegend = "Deviance")
#Deviances increase with abundance, but not with library sizes.
```

### Quadratic response functions

These response functions may be more realistic, but their graphs are harder to interpret. Also for this dataset it simply won't converge.

```{r plotCMETquad, purl = FALSE, eval = FALSE, echo = FALSE}
plot(armpitRCMconstrQuad, plotType = c("samples","variables"))
```

### Non-parametric response functions

These response functions are very data driven, but have the drawback that they do not allow to visualize the role of the taxa in the ordination.

```{r plotCMETnonParam, purl = FALSE}
plot(armpitRCMconstrNonParam, plotType = "samples")
```

Also with non-parametric response functions there are no clear clusters, but then again this is an observational setup. We do see two outlying samples though, namely samples `r names(which(((armpitRCMconstrNonParam$covariates %*% armpitRCMconstrNonParam$alpha)[,1] * armpitRCMconstrNonParam$psis[1]) >1.5))` 

```{r plotCMETnonParam2, purl = FALSE}
plot(armpitRCMconstrNonParam, plotType = c("variables", "samples"))
```

Deo use, washing and odor_panel seem to be driving variables of the environmental gradient. But should a "resulting variable" such as odour be part of the fit? The environmental gradients are very different from linear response functions. This is likely due to the high number of variables.

```{r corVars, purl = FALSE, include = FALSE}
cor(armpitRCMconstrLin$alpha, armpitRCMconstrNonParam$alpha)
plot(armpitRCMconstrLin$alpha[,1], armpitRCMconstrNonParam$alpha[,1], type = "n")
text(armpitRCMconstrLin$alpha[,1], armpitRCMconstrNonParam$alpha[,1], labels = rownames(armpitRCMconstrNonParam$alpha), cex = 0.3)
abline(0,1, lty = "dotted")
```

```{r plotCMETnonParamDeo, purl = FALSE}
plot(armpitRCMconstrNonParam, plotType = c("variables", "samples"), samColour = "deo_p_week")
```

The most extreme outlier seems to be due to excessive deo use. The fact that it only shows up in this graph indicates it might be an abberation of the model rather than a true biological outlier. The model fit is based on low values of deo use, for >60 it merely extrapolates. Let's see if this sample indeed displays poor fit. Herefore we look at the average deviance of the samples.

```{r CMETnonParamDev, purl = FALSE, eval = FALSE}
devNonParam = getDeviance(armpitRCMconstrNonParam)
plot(armpitRCMconstrNonParam, plotType = c( "samples"), samColour = rowMeans(devNonParam), colLegend = "Deviance")
```

The outliers have low deviances, but is this because they pull the fit towards them? For this purpose we check the influence functions.

The results with less variables

### Linear response function

These constrained models were fitted with as only variables:

 * Gender
 * BMI
 * Fastfood
 * Meat
 * Vegetables

```{r plotCMETLinLess, purl = FALSE}
plot(armpitRCMconstrLinLess, plotType = c("species","variables"))
```

With 

```{r plotCMETLinLess2, purl = FALSE}
plot(armpitRCMconstrLinLess)
```

### Nonparametric response function

```{r plotCMETnonParamLess, purl = FALSE}
plot(armpitRCMconstrNonParamLess)
```