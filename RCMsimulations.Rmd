---
title: "RCM simulations"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  pdf_document:
    includes:
      in_header: packagesRCM.sty
---

```{r setup, warning=FALSE, message=FALSE, echo=FALSE, purl=TRUE}
WD = "/home/stijn/PhD/Biplots"
knitr::opts_knit$set(root.dir = WD)
knitr::opts_chunk$set(cache = TRUE, autodep = TRUE,  warning = FALSE, message=FALSE, echo=FALSE, eval=TRUE, tidy = TRUE, fig.width = 9, fig.height=6, purl=TRUE, fig.show = "hold", cache.lazy = FALSE)
# The required package list:
reqpkg <- c("phyloseq", "parallel", "ggplot2", "vegan", "reshape2") #"DirFactor","MASS",
# Load all required packages and show version
for(i in reqpkg)
{
#   print(i) 
#   print(packageVersion(i))
  library(i, quietly = TRUE, verbose = FALSE, warn.conflicts = FALSE, character.only = TRUE)
} 
if(detectCores()==4) setwd(WD)
par(pty="s", mar = c(8,2,4,2), cex.main = 0.9) #Make sure the biplots are square!
palStore = grep("black",palette(), value =TRUE, invert = TRUE)
palette(palStore)
levelsMeth = c("CApearson","CAcontRat","CAchisq","DCA", "Hellinger","DPCOA","BC","BCrel","BCrelNMDS", "JSD","UniFrac","wUniFrac", "CoDa","RCM", "Control")
labelsMeth = c("CApearson","CAcontRat","CAchisq","DCA","Hellinger","DPCOA","Bray-Curtis-Abs","Bray-Curtis","Bray-Curtis NMDS", "JSD","UniFrac","weighted UniFrac","CoDa","RCM", "Control")
groupsMeth = factor(c("Independence","Independence","Independence","Independence","Independence","Distance","Distance","Distance","Distance","Distance","Distance","Distance", "CoDa", "RCM"), levels = c("Independence", "Distance", "CoDa", "RCM"), ordered = TRUE)
names(groupsMeth) = grep(levelsMeth, value  = TRUE, pattern ="Control", invert = TRUE)
factorMeth = factor(levelsMeth, levels = levelsMeth, labels = labelsMeth)
borderCol = "black"
funFiles = dir("R")
funFilesPub = dir("pubFun")
for (i in funFiles) {source(file.path("R",i))}
for (i in funFilesPub) {source(file.path("pubFun",i))};rm(i)
# load("/home/stijn/PhD/American Gut/AGphylo.RData")
load("/home/stijn/PhD/Simulations/data/physeqListV13.RData")
load("/home/stijn/PhD/Simulations/data/MLES.RData") #Load observed parameter values
```

# Simulation setup

## Unconstrained RC(M)

As ways of generating test datasets we see three different options

  1) Parametric simulation with the negative binomial with known abundances. 
  2) Non-parametric simulation with SimSeq
  3) Real datasets with biological signal allegedly known
  
  Parametric simulation is needed as a first check but evidently favours our method (if we use the negative binomial distribution). SimSeq is a reasonably neutral tool, we will only use WMW to obtain the lfdr. Real datasets will need to complement our analysis but it may not be possible to evaluate them in a high-throughput way, this will need to happen empirically.
  
### Parametric simulations

#### Negative binomial

The negative binomial is the assumed distribution of our method. As a result we should outperform all other methods in this setting.

\clearpage

##### Null setting

In this setting we simulate all distributions from the same template, thus there is no signal in this dataset

```{r NBnull, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions
rhoEst = unlist(rhoMLEs) #observed relative abundances, pooled
thetaEst = 1/unlist(phiMLEs) #observed dispersions abundances, pooled

#Library sizes
libSizesEst = unlist(sapply(physeqListV13, sample_sums)) #Resample
if(!file.exists(file = "RCMsim/resList0.RData")){
  if(!file.exists(file = "RCMsim/datList0.RData")){
datList0 = mclapply(mc.cores=1, 1:reps, function(i){
## Sample parameters
rhosSampled = sample(rhoEst, p)
thetasSampled = sample(thetaEst, p) #Sampled dispersions are the same in every population, this is the ideal case assumed by our method.
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes

## Create dataset
meanMat = outer(libSizesSampled, rhosSampled)
dataMat = matrix(rnbinom(prod(dim(meanMat)), mu = meanMat, size = matrix(thetasSampled,n,p,byrow = TRUE)),n,p)
dataMat = dataMat[rowSums(dataMat)>0,colSums(dataMat)>0]
list(dataMat = dataMat, libSizesSampled = libSizesSampled, thetasSampled = thetasSampled, rhosSampled = rhosSampled)
})
save(datList0,  file = "RCMsim/datList0.RData")
} else {load(file = "RCMsim/datList0.RData")}

# Results
  if(!file.exists("RCMsim/resList0RCM.RData")){
RCMresList0 = mclapply(mc.cores=4, datList0, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList0, file = "RCMsim/resList0RCM.RData")
} else {load("RCMsim/resList0RCM.RData")}
resList0 = otherAnalyses(RCMresList0)
resList0Rows = lapply(resList0, extractRows)
resList0Cols = mapply(resList0, resList0Rows, FUN=extractCols, SIMPLIFY=FALSE)

datList0 = lapply(RCMresList0, function(x){x$X})
CorDF0lib = makeCorDf(resList0Rows, datList0, scoreDim = "rows", dataMat = TRUE, groupMeth = groupsMeth)
CorDF0tax = makeCorDf(resList0Cols, datList0, scoreDim = "columns", dataMat = TRUE, groupMeth = groupsMeth)
rm(resList0Rows, resList0, datList0, resList0Cols);gc(verbose = FALSE)
save(CorDF0lib, CorDF0tax, file = "RCMsim/resList0.RData")
} else {load(file = "RCMsim/resList0.RData")}
rm(physeqListV13);gc(verbose = FALSE)
```

```{r Starting Values, purl = FALSE, eval = FALSE}
startList= lapply(resList0, startFun)
moltStart = melt(startList, value.name = "correlation")
names(moltStart) = c("correlation", "scores","run")
boxplot(correlation ~ scores, data = moltStart, las=2)
abline(h=0, col ="red", lty = "dashed")
#Squared weighing clearly gives the best results, although no fantastic correlations.
```

\clearpage

##### Null setting, different library sizes

In this setting we simulate all distributions from the same template, but with ten-fold differences in library sizes. Stiill there is thus no signal in this dataset.

```{r NBnullb, purl = FALSE, eval =FALSE}
if(!file.exists(file = "RCMsim/resList0b.RData")){
  if(!file.exists(file = "RCMsim/datList0b.RData")){
datList0b = mclapply(mc.cores=1, 1:reps, function(i){
## Sample parameters
rhosSampled = sample(rhoEst, p)
thetasSampled = sample(thetaEst, p) #Sampled dispersions are the same in every population, this is the ideal case assumed by our method.
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes
libSizesSampled[seq_len(n/2)] = libSizesSampled[seq_len(n/2)]*10 #Apply the ten-fold change in library sizes

## Create dataset
meanMat = outer(libSizesSampled, rhosSampled)
dataMat = matrix(rnbinom(prod(dim(meanMat)), mu = meanMat, size = matrix(thetasSampled,n,p,byrow = TRUE)),n,p)
dataMat = dataMat[rowSums(dataMat)>0,colSums(dataMat)>0]
list(dataMat = dataMat, libSizesSampled = libSizesSampled, thetasSampled = thetasSampled, rhosSampled = rhosSampled)
})
save(datList0b,  file = "RCMsim/datList0b.RData")
} else {load(file = "RCMsim/datList0b.RData")}

# Results
  if(!file.exists("RCMsim/resList0RCMb.RData")){
RCMresList0b = mclapply(mc.cores=4, datList0b, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList0b, file = "RCMsim/resList0RCMb.RData")
} else { load("RCMsim/resList0RCMb.RData")}
resList0b = otherAnalyses(RCMresList0b)
resList0bRows = lapply(resList0b, extractRows)
resList0bCols = mapply(resList0b, resList0bRows, FUN=extractCols, SIMPLIFY=FALSE)
save(resList0b, resList0bRows,resList0bCols,  file = "RCMsim/resList0b.RData")
} else {load(file = "RCMsim/resList0b.RData")}
```

##### Null setting, differences in dispersions

In this setting we simulate all distributions from the same template, but with group differences in dispersion. The group factor (e.g. sequencing center) may not act on the mean, but on the dispersion. Ordination techniques should be immune to this effect.

```{r NBnullc, purl = FALSE, eval = FALSE}
if(!file.exists(file = "RCMsim/resList0c.RData")){
  if(!file.exists(file = "RCMsim/datList0c.RData")){
datList0c = mclapply(mc.cores=1, 1:reps, function(i){
## Sample parameters
rhosSampled = sample(rhoEst, p)
thetasSampled = sample(thetaEst, p) #Sampled dispersions differ between some groups with equal means
thetasSampled2 = thetasSampled/10 # A ten-fold increase in dispersion
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes

## Create dataset
meanMat = outer(libSizesSampled, rhosSampled)
dataMat1 = matrix(rnbinom(prod(dim(meanMat))/2, mu = meanMat[seq_len(n/2),], size = matrix(thetasSampled,n/2,p,byrow = TRUE)),n/2,p)
dataMat2 = matrix(rnbinom(prod(dim(meanMat))/2, mu = meanMat[seq_len(n/2),], size = matrix(thetasSampled2,n/2,p,byrow = TRUE)),n/2,p)
dataMat = rbind(dataMat1, dataMat2)
dataMat = dataMat[rowSums(dataMat)>0,colSums(dataMat)>0]
list(dataMat = dataMat, libSizesSampled = libSizesSampled, thetasSampled = thetasSampled, rhosSampled = rhosSampled)
})
save(datList0c,  file = "RCMsim/datList0c.RData")
} else {load(file = "RCMsim/datList0c.RData")}

# Results
  if(!file.exists("RCMsim/resList0RCMc.RData")){
RCMresList0c = mclapply(mc.cores=4, datList0b, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList0c, file = "RCMsim/resList0RCMc.RData")
} else { load("RCMsim/resList0RCMc.RData")}
resList0c = otherAnalyses(RCMresList0c)
resList0cRows = lapply(resList0c, extractRows)
resList0cCols = mapply(resList0c, resList0cRows, FUN = extractCols, SIMPLIFY=FALSE)
save(resList0c, resList0cRows,resList0cCols,  file = "RCMsim/resList0c.RData")
} else {load(file = "RCMsim/resList0c.RData")}
```

##### Simulate under H0, but with differences in dispersion

Inspired by Warton _et al._ (2012): "Distance-based multivariate analyses confound location and dispersion effects" we set up a simulation without any signal, but whereby the dispersions in the different groups are different, as a result of the group effect itself or related sampling effects. Note that this also violates the assumption of our RC(M) method of constant dispersions.

```{r NBdispsersion, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactor4 = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor
if(!file.exists(file = "RCMsim/resList4.RData")){
  if(!file.exists(file = "RCMsim/datList4.RData")){
datList4 = mclapply(mc.cores = 4, 1:reps, function(i){
## Sample parameters
rhosSampled = sample(rhoEst, p)
thetasSampled = sample(thetaEst, p) 
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes
#Sampled dispersions differ between the population
thetaMat = matrix(thetasSampled, n, p, byrow = TRUE) * c(rep(c(0.2,0.5,1,5), eac = nPerPop)) #Modify dispersions to 5 times, 2 times and 0.2 times the normal levels

## Create dataset
meanMat = outer(libSizesSampled, rhosSampled)
dataMat = matrix(rnbinom(prod(dim(meanMat)), mu = meanMat, size = thetaMat),n,p)
dataMat = dataMat[rowSums(dataMat)>0,colSums(dataMat)>0]
list(dataMat = dataMat, libSizesSampled = libSizesSampled, thetaMat = thetaMat, rhosSampled = rhosSampled)
})
save(datList4,groupFactor4,  file = "RCMsim/datList4.RData")
} else {load(file = "RCMsim/datList4.RData")}

# Results
  if(!file.exists("RCMsim/resList4RCM.RData")){
RCMresList4 = mclapply(mc.cores=4, datList4, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList4, file = "RCMsim/resList4RCM.RData")
} else {load("RCMsim/resList4RCM.RData")}
resList4 = otherAnalyses(RCMresList4)
resList4Rows = lapply(resList4, extractRows)
resList4Cols = mapply(resList4, resList4Rows,FUN = extractCols, SIMPLIFY = FALSE)

resList4 = otherAnalyses(RCMresList4)
resList4Rows = lapply(resList4, extractRows)
resList4Cols = mapply(resList4, resList4Rows,FUN = extractCols, SIMPLIFY = FALSE)
datList4 = lapply(RCMresList4, function(x){x$X})
CorDF4lib = makeCorDf(resList4Rows, datList4, scoreDim = "rows", dataMat = TRUE, groupMeth = groupsMeth)
CorDF4tax = makeCorDf(resList4Cols, datList4, scoreDim = "columns", dataMat = TRUE, groupMeth = groupsMeth)
rm(resList4Rows, resList4, datList4, resList4Cols);gc(verbose = FALSE)
save(CorDF4lib, CorDF4tax, file = "RCMsim/resList4.RData")

} else {load(file = "RCMsim/resList4.RData")}
```

\clearpage

##### Simulate from different distributions

In this setting we will simulate data from 4 unrelated negative binomial distributions. Because of this clustering should be very good.

```{r NBunrelatedDistr, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactor1 = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor

if(!file.exists(file = "RCMsim/resList1.RData")){
  if(!file.exists(file = "RCMsim/datList1.RData")){
datList1 = mclapply(mc.cores=1, 1:reps, function(i){
## Sample parameters
rhosSampled = sapply(1:nPop, function(x){tmp=sample(rhoEst, p); tmp/sum(tmp)})[,groupInd]
thetasSampled = sample(thetaEst, p) #Sampled dispersions are the same in every population, this is the ideal case assumed by our method.
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes

## Create dataset
meanMat = libSizesSampled * t(rhosSampled)
dataMat = matrix(rnbinom(prod(dim(meanMat)), mu = meanMat, size = matrix(thetasSampled,n,p, byrow = TRUE)),n,p)
list(dataMat = dataMat, group = groupFactor1, libSizesSampled = libSizesSampled, thetasSampled = thetasSampled, rhosSampled = rhosSampled)
})
save(datList1,groupFactor1,  file = "RCMsim/datList1.RData")
} else {load(file = "RCMsim/datList1.RData")}

# Results

  if(!file.exists("RCMsim/resList1RCM.RData")){
RCMresList1 = mclapply(mc.cores = 4, datList1, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList1, file = "RCMsim/resList1RCM.RData")
} else {load("RCMsim/resList1RCM.RData")}
resList1 = otherAnalyses(RCMresList1, cores = 4)
resList1Rows = lapply(resList1, extractRows)
resList1Cols = mapply(resList1, resList1Rows,FUN = extractCols, SIMPLIFY = FALSE)
SilDF1 = makeSilDf(resList1Rows, groupFactor1)
datList1 = lapply(RCMresList1, function(x){x$X})
CorDF1lib = makeCorDf(resList1Rows, datList1, scoreDim = "rows", dataMat = TRUE, groupMeth = groupsMeth)
CorDF1tax = makeCorDf(resList1Cols, datList1, scoreDim = "columns", dataMat = TRUE, groupMeth = groupsMeth)
distDF1 = makeDistDf(resList1Rows, groupFactor1)
rm(resList1Rows, resList1, datList1, resList1Cols);gc(verbose = FALSE)
save(CorDF1lib, CorDF1tax, SilDF1, distDF1, file = "RCMsim/resList1.RData")
} else {load(file = "RCMsim/resList1.RData")}
```

##### Simulate from related distributions

In this setting we will simulate data from 4 related negative binomial distributions, all obtained from the same mother distributions but 10\% of the taxa have modified abundances

```{r NBrelatedDistr, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions
TPR = 0.1
FC = 5

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactor2 = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor
if(!file.exists(file = "RCMsim/resList2.RData")){
  if(!file.exists(file = "RCMsim/datList2.RData")){
datList2 = mclapply(mc.cores = 1, 1:reps, function(i){
## Sample parameters
rhosSampled0 = sample(rhoEst, p)
rhosSampled0 = rhosSampled0/sum(rhosSampled0)
#For each population, modify a fraction TPR of the abundances (compensation is not so badly needed here, we do not test individual species). Record the taxa that have been modified.
rhosIDSampled = lapply(1:nPop, function(x, rhos){
  id = sample(seq_len(p), round(TPR*p))
  rhos[id] = rhos[id]*FC
  cbind(rhos = rhos/sum(rhos), id = id) #renormalize
}, rhos = rhosSampled0)

rhosSampled00 = sapply(rhosIDSampled, function(x){x[, "rhos"]})
rhosSampled = rhosSampled00[,groupInd]
IDsampled = sapply(rhosIDSampled, function(x){x[, "id"]})

thetasSampled = sample(thetaEst, p) 
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes

## Create dataset
meanMat = libSizesSampled * t(rhosSampled)
dataMat = matrix(rnbinom(prod(dim(meanMat)), mu = meanMat, size = matrix(thetasSampled,n,p,byrow = TRUE)),n,p)
colnames(dataMat) = rownames(rhosSampled) 
rownames(dataMat) = groupFactor2
dataMat = dataMat[rowSums(dataMat)>0,colSums(dataMat)>0]
list(dataMat = dataMat, libSizesSampled = libSizesSampled, thetasSampled = thetasSampled, rhosSampled = rhosSampled00, IDsampled = IDsampled)
})
save(datList2,groupFactor2,  file = "RCMsim/datList2.RData")
} else {load(file = "RCMsim/datList2.RData")}

# Results

  if(!file.exists("RCMsim/resList2RCM.RData")){
RCMresList2 = mclapply(mc.cores=4, datList2, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList2, file = "RCMsim/resList2RCM.RData")
} else {load("RCMsim/resList2RCM.RData")}
resList2 = otherAnalyses(RCMresList2, cores = 4)
IDlist2 = lapply(datList2, function(x){
   id = apply(x$IDsampled, 2, unique)
   taxa = apply(id, 2, function(y){rownames(x$rhosSampled)[y]})
   })
resList2Rows = lapply(resList2, extractRows)
resList2Cols = mapply(resList2, resList2Rows,FUN = extractCols, SIMPLIFY = FALSE)

datList2 = lapply(RCMresList2, function(x){x$X})
SilDF2 = makeSilDf(resList2Rows, groupFactor2)
CorDF2lib = makeCorDf(resList2Rows, datList2, scoreDim = "rows", dataMat = TRUE, groupMeth = groupsMeth)
CorDF2tax = makeCorDf(resList2Cols, datList2, scoreDim = "columns", dataMat = TRUE, groupMeth = groupsMeth)
distDF2 = makeDistDf(resList2Rows, groupFactor2)
contr2 = contrTaxaWrap(resList2Rows, resList2Cols, IDlist2, groupFactor2)
rm(resList2Rows, resList2, datList2, resList2Cols, IDlist2);gc(verbose = FALSE)
save(CorDF2lib, CorDF2tax, SilDF2, distDF2, contr2, file = "RCMsim/resList2.RData")
} else {load(file = "RCMsim/resList2.RData")}
```

\clearpage

##### Simulate from related distributions, confounded by library sizes

In this setting we will again simulate data from 4 related negative binomial distributions, all obtained from the same mother distributions but 10\% of the taxa have modified abundances. In this case we will make the library sizes different in each group. Th initial library sizes are all sampled from the same pool of library sizes observed in real data. The first group has unmodified library sizes, the second group library sizes multiplied by 1.5, the third by 2 and the fourth by 3.

```{r NBrelatedDistrConf, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions
TPR = 0.1
FC = 5

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactor3 = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor
if(!file.exists(file = "RCMsim/resList3.RData")){
  if(!file.exists(file = "RCMsim/datList3.RData")){
datList3 = mclapply(mc.cores = 4, 1:reps, function(i){
## Sample parameters
rhosSampled0 = sample(rhoEst, p)
rhosSampled0 = rhosSampled0/sum(rhosSampled0)
#For each population, modify a fraction TPR of the abundances (compensation is not so badly needed here, we do not test individual species). Record the taxa that have been modified.
rhosIDSampled = lapply(1:nPop, function(x, rhos){
  id = sample(seq_len(p), round(TPR*p))
  rhos[id] = rhos[id]*FC
  cbind(rhos = rhos/sum(rhos), id = id) #renormalize
}, rhos = rhosSampled0)

rhosSampled00 = sapply(rhosIDSampled, function(x){x[, "rhos"]})
rhosSampled = rhosSampled00[,groupInd]
IDsampled = sapply(rhosIDSampled, function(x){x[, "id"]})

thetasSampled = sample(thetaEst, p) 
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes, confounded with group membership
libSizesSampled[groupInd==2] = round(libSizesSampled[groupInd==2]*1.5)
libSizesSampled[groupInd==3] = round(libSizesSampled[groupInd==3]*2)
libSizesSampled[groupInd==4] = round(libSizesSampled[groupInd==4]*3)

## Create dataset
meanMat = libSizesSampled * t(rhosSampled)
dataMat = matrix(rnbinom(prod(dim(meanMat)), mu = meanMat, size = matrix(thetasSampled,n,p,byrow = TRUE)),n,p)
colnames(dataMat) = rownames(rhosSampled) 
rownames(dataMat) = groupFactor3
dataMat = dataMat[rowSums(dataMat)>0,colSums(dataMat)>0]
list(dataMat = dataMat, libSizesSampled = libSizesSampled, thetasSampled = thetasSampled, rhosSampled = rhosSampled00, IDsampled = IDsampled)
})
save(datList3,groupFactor3,  file = "RCMsim/datList3.RData")
} else {load(file = "RCMsim/datList3.RData")}

# Results
  if(!file.exists("RCMsim/resList3RCM.RData")){
RCMresList3 = mclapply(mc.cores=4, datList3, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList3, file = "RCMsim/resList3RCM.RData")
} else {load("RCMsim/resList3RCM.RData")}
resList3 = otherAnalyses(RCMresList3)
IDlist3 = lapply(datList3, function(x){
   id = apply(x$IDsampled, 3, unique)
   taxa = apply(id, 3, function(y){rownames(x$rhosSampled)[y]})
   })
resList3Rows = lapply(resList3, extractRows)
resList3Cols = mapply(resList3, resList3Rows,FUN = extractCols, SIMPLIFY = FALSE)

datList3 = lapply(RCMresList3, function(x){x$X})
SilDF3 = makeSilDf(resList3Rows, groupFactor3)
CorDF3lib = makeCorDf(resList3Rows, datList3, scoreDim = "rows", dataMat = TRUE, groupMeth = groupsMeth)
CorDF3tax = makeCorDf(resList3Cols, datList3, scoreDim = "columns", dataMat = TRUE, groupMeth = groupsMeth)
distDF3 = makeDistDf(resList3Rows, groupFactor3)
contr3 = contrTaxaWrap(resList3Rows, resList3Cols, IDlist3, groupFactor3)
rm(resList3Rows, resList3, datList3, resList3Cols);gc(verbose = FALSE)
save(CorDF3lib, CorDF3tax, SilDF3, distDF3, contr3, file = "RCMsim/resList3.RData")
} else {load(file = "RCMsim/resList3.RData")}
```

##### Simulate under H1, with correlated taxa

We know that taxa living in the same niche are dependent on each other, and as a result their abundances are correlated. This phenomenon can affect the differentialn abundance detection, so it could also affect our visualization procedures. I would also expect it to have an effect on the CoDa method, which relies on ratios between taxa of the same sample. We'll use the correlation networks previously estimated from the HMP and AGP datasets.

```{r NBrelatedDistrCorr, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions
TPR = 0.1
FC = 5

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactor5 = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor
if(!file.exists(file = "RCMsim/resList5.RData")){
  if(!file.exists(file = "RCMsim/datList5.RData")){
    load("/home/stijn/PhD/Simulations/data/covList.RData")
    require(SpiecEasi)
datList5 = mclapply(mc.cores = 4, 1:reps, function(i){
## Sample parameters
rhosSampled0 = sample(rhoEst, p)
rhosSampled0 = rhosSampled0/sum(rhosSampled0)
#For each population, modify a fraction TPR of the abundances (compensation is not so badly needed here, we do not test individual species). Record the taxa that have been modified.
rhosIDSampled = lapply(1:nPop, function(x, rhos){
  id = sample(seq_len(p), round(TPR*p))
  rhos[id] = rhos[id]*FC
  cbind(rhos = rhos/sum(rhos), id = id) #renormalize
}, rhos = rhosSampled0)

rhosSampled00 = sapply(rhosIDSampled, function(x){x[, "rhos"]})
rhosSampled = rhosSampled00[,groupInd]
IDsampled = sapply(rhosIDSampled, function(x){x[, "id"]})

thetasSampled = sample(thetaEst, p) 
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes, confounded with group membership
covMatName = sample(names(covList), 1)

## Create dataset
meanMat = libSizesSampled * t(rhosSampled)

dataMat = rmvnegbin(n = n,mu = meanMat, ks = thetasSampled, Sigma = as.matrix(covList[[covMatName]]))
colnames(dataMat) = rownames(rhosSampled) 
rownames(dataMat) = groupFactor5
dataMat = dataMat[rowSums(dataMat)>0,colSums(dataMat)>0]
list(dataMat = dataMat, libSizesSampled = libSizesSampled, thetasSampled = thetasSampled, rhosSampled = rhosSampled00, IDsampled = IDsampled, covMatName = covMatName)
})
save(datList5,groupFactor5,  file = "RCMsim/datList5.RData")
rm(covList);gc(verbose = FALSE)
} else {load(file = "RCMsim/datList5.RData")}

# Results
  if(!file.exists("RCMsim/resList5RCM.RData")){
RCMresList5 = mclapply(mc.cores=4, datList5, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList5, file = "RCMsim/resList5RCM.RData")
} else {load("RCMsim/resList5RCM.RData")}
resList5 = otherAnalyses(RCMresList5)
IDlist5 = lapply(datList5, function(x){
   id = apply(x$IDsampled, 5, unique)
   taxa = apply(id, 5, function(y){rownames(x$rhosSampled)[y]})
   })
resList5Rows = lapply(resList5, extractRows)
resList5Cols = mapply(resList5, resList5Rows,FUN = extractCols, SIMPLIFY = FALSE)

datList5 = lapply(resList5, function(x){x$RCM$X})
SilDF5 = makeSilDf(resList5Rows, groupFactor5)
CorDF5lib = makeCorDf(resList5Rows, datList5, scoreDim = "rows", dataMat = TRUE, groupMeth = groupsMeth)
CorDF5tax = makeCorDf(resList5Cols, datList5, scoreDim = "columns", dataMat = TRUE, groupMeth = groupsMeth)
distDF5 = makeDistDf(resList5Rows, groupFactor5)
contr5 = contrTaxaWrap(resList5Rows, resList5Cols, IDlist5, groupFactor5)
rm(resList5Rows, resList5, datList5, resList5Cols);gc(verbose = FALSE)
save(CorDF5lib, CorDF5tax, SilDF5, distDF5, contr5, file = "RCMsim/resList5.RData")
} else {load(file = "RCMsim/resList5.RData")}
```

##### Negative binomial with phylogenetic information

In order to also include the very popular distance measures UniFrac and weighted UniFrac, we also generate data with the negative binomial and Dirichlet multinomial taking into account phylogenetic structure. We base our strategy on the second strategy described by Chen _et al._ ("Associating microbiome composition with environmental
covariates using generalized UniFrac distances", 2012). We generate random trees for the template vector of relative abundances, and modify abundances within one of the 20 clusters.

```{r UniFrac, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions
TPR = 0.1
FC = 5
k = round(1/TPR) #Number of clusters

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactorPhy = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor

clusters = seq_len(k)

if(!file.exists(file = "RCMsim/resListPhy.RData")){
  if(!file.exists(file = "RCMsim/datListPhy.RData")){
    require(ape)
    require(cluster)
datListPhy = mclapply(mc.cores = 4, 1:reps, function(i){
## Sample parameters
cluSampled = sample(clusters, nPop) #Cluster to be made DA

rhosSampled0 = sample(rhoEst, p)
rhosSampled0 = rhosSampled0/sum(rhosSampled0)

randomTree = rcoal(n = p, tip.label = names(rhosSampled0)) # The random tree, use rcoal to make it ultrametric
psclust = cutree(as.hclust(randomTree), k = k) #Split into clusters
names(psclust) = randomTree$tip.label #Assign names
psclust = psclust[names(rhosSampled0)] #Reorder according to the rhos

#For each population, modify the abundances of a cluster of related taxa. Record the clusters that have been modified.
rhosIDSampled = lapply(cluSampled, function(x, rhos){
  id = x == psclust
  rhos[id] = rhos[id]*FC
  cbind(rhos = rhos/sum(rhos), id = id) #renormalize
}, rhos = rhosSampled0)

rhosSampled00 = sapply(rhosIDSampled, function(x){x[, "rhos"]})
rhosSampled = rhosSampled00[,groupInd]
IDsampled = sapply(rhosIDSampled, function(x){x[, "id"]})

thetasSampled = sample(thetaEst, p) 
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes

## Create dataset
meanMat = libSizesSampled * t(rhosSampled)
dataMat = matrix(rnbinom(prod(dim(meanMat)), mu = meanMat, size = matrix(thetasSampled,n,p,byrow = TRUE)),n,p)
colnames(dataMat) = rownames(rhosSampled) 
rownames(dataMat) = groupFactorPhy
dataMat = dataMat[rowSums(dataMat)>0,colSums(dataMat)>0]
list(dataMat = dataMat, libSizesSampled = libSizesSampled, thetasSampled = thetasSampled, rhosSampled = rhosSampled00, IDsampled = IDsampled, cluSampled = cluSampled, randomTree = randomTree)
})
save(datListPhy, groupFactorPhy, file = "RCMsim/datListPhy.RData")
} else {load(file = "RCMsim/datListPhy.RData")}

# Results
 if(!file.exists("RCMsim/resListPhyRCM.RData")){
RCMresListPhy = mclapply(mc.cores=4, datListPhy, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresListPhy, file = "RCMsim/resListPhyRCM.RData")
  } else {load("RCMsim/resListPhyRCM.RData")}
listID = sapply(RCMresListPhy, is.list)
resListPhy = otherAnalyses(RCMresListPhy[listID], unifrac = TRUE, treeList = lapply(datListPhy[listID], function(x){x$randomTree}), cores = 4 )
IDlistPhy = lapply(datListPhy[listID], function(x){
   taxa = lapply(seq_len(ncol(x$IDsampled)), function(y){rownames(x$rhosSampled)[as.logical(x$IDsampled[,y])]})
   })
resListPhyRows = lapply(resListPhy, extractRows)
resListPhyCols = mapply(resListPhy, resListPhyRows,FUN = extractCols, SIMPLIFY = FALSE)

datListPhy = lapply(RCMresListPhy, function(x){x$X})
SilDFPhy = makeSilDf(resListPhyRows, groupFactorPhy)
CorDFPhylib = makeCorDf(resListPhyRows, datListPhy, scoreDim = "rows", dataMat = TRUE, groupMeth = groupsMeth)
CorDFPhytax = makeCorDf(resListPhyCols, datListPhy, scoreDim = "columns", dataMat = TRUE, groupMeth = groupsMeth)
distDFPhy = makeDistDf(resListPhyRows, groupFactorPhy)
contrPhy = contrTaxaWrap(resListPhyRows, resListPhyCols, IDlistPhy, groupFactorPhy)
rm(resListPhyRows, resListPhy, datListPhy, resListPhyCols);gc(verbose = FALSE)
save(CorDFPhylib, CorDFPhytax, SilDFPhy, distDFPhy, contrPhy, file = "RCMsim/resListPhy.RData")
} else {load(file = "RCMsim/resListPhy.RData")}
```

#### Other distributions

We also simulate datasets from other distributions than the negative binomial to see how the method behaves when its distributional assumptions are violated.

##### Zero-inflated negative binomial distribution

The zero-inflated negative binomial (ZINB) distribution was used by Zhang _et al._ (2016) for differential abundance testing. Our own goodness-of-fit tests indicate that for 14\% of the taxa, the ZINB provides a better fit than the regular NB

```{r simZINB}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions
TPR = 0.1
FC = 5

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactorZINB = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor

if(!file.exists(file = "RCMsim/resListZINB.RData")){
load(file="/home/stijn/PhD/Biplots/Zicoef.RData")

if(!file.exists(file = "RCMsim/datListZINB.RData")){
  require(pscl)
datListZINB = mclapply(mc.cores=1, 1:reps, function(i){
## Sample parameters
rhosSampled0 = sample(rhoEst, p)
rhosSampled0 = rhosSampled0/sum(rhosSampled0)
#For each population, modify a fraction TPR of the abundances (compensation is not so badly needed here, we do not test individual species). Record the taxa that have been modified.
rhosIDSampled = lapply(1:nPop, function(x, rhos){
  id = sample(seq_len(p), round(TPR*p))
  rhos[id] = rhos[id]*FC
  cbind(rhos = rhos/sum(rhos), id = id) #renormalize
}, rhos = rhosSampled0)

rhosSampled00 = sapply(rhosIDSampled, function(x){x[, "rhos"]})
rhosSampled = rhosSampled00[,groupInd]
IDsampled = sapply(rhosIDSampled, function(x){x[, "id"]})

thetasSampled = sample(thetaEst, p) 
propSampled = expit(sample(ZIcoef, p))
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes

## Create dataset
meanMat = libSizesSampled * t(rhosSampled)
dataMat = matrix(rzinegbin(prod(dim(meanMat)), munb = meanMat, size = matrix(thetasSampled,n,p, byrow = TRUE), pstr0 = matrix(propSampled,n,p,byrow = TRUE)),n,p)
colnames(dataMat) = rownames(rhosSampled) 
rownames(dataMat) = groupFactorZINB
dataMat = dataMat[rowSums(dataMat)>0,colSums(dataMat)>0]
list(dataMat = dataMat, libSizesSampled = libSizesSampled, thetasSampled = thetasSampled, rhosSampled = rhosSampled00, IDsampled = IDsampled, propSampled = propSampled)
})
save(datListZINB,groupFactorZINB,  file = "RCMsim/datListZINB.RData")
} else {load(file = "RCMsim/datListZINB.RData")}

# Results

 if(!file.exists("RCMsim/resListZINBRCM.RData")){
RCMresListZINB = mclapply(mc.cores=4, datListZINB, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresListZINB, file = "RCMsim/resListZINBRCM.RData")
} else {load("RCMsim/resListZINBRCM.RData")}
resListZINB = otherAnalyses(RCMresListZINB, cores = 4)
IDlistZINB = lapply(datListZINB, function(x){
  id = apply(x$IDsampled, 2, unique)
  taxa = apply(id, 2, function(y){rownames(x$rhosSampled)[y]})
  })
resListZINBRows = lapply(resListZINB, extractRows)
resListZINBCols = mapply(resListZINB, resListZINBRows, FUN = extractCols, SIMPLIFY = FALSE)

datListZINB = lapply(RCMresListZINB, function(x){x$X})
SilDFZINB = makeSilDf(resListZINBRows, groupFactorZINB)
CorDFZINBlib = makeCorDf(resListZINBRows, datListZINB, scoreDim = "rows", dataMat = TRUE, groupMeth = groupsMeth)
CorDFZINBtax = makeCorDf(resListZINBCols, datListZINB, scoreDim = "columns", dataMat = TRUE, groupMeth = groupsMeth)
distDFZINB = makeDistDf(resListZINBRows, groupFactorZINB)
contrZINB = contrTaxaWrap(resListZINBRows, resListZINBCols, IDlistZINB, groupFactorZINB)
rm(resListZINBRows, resListZINB, datListZINB, resListZINBCols);gc(verbose = FALSE)
save(CorDFZINBlib, CorDFZINBtax, SilDFZINB, distDFZINB, contrZINB, file = "RCMsim/resListZINB.RData")
} else {load(file = "RCMsim/resListZINB.RData")}
```

##### Dirichlet-multinomial

The use of the Dirichlet multinomial for microbiome data was proposed by La Rosa _et al._ (2012). Although it is very restrictive in terms of variance and covariance structures, we include it here because of its relative popularity. Also Chen _et al._ (2012) use it to simulate data for a visualization.

```{r simDM, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions
TPR = 0.1
FC = 5

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactorDM = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor
load("/home/stijn/PhD/American Gut/AGdm.RData")

if(!file.exists(file = "RCMsim/datListDM.RData")){
  require(HMP)
datListDM = mclapply(mc.cores = 1, 1:reps, function(i){
## Sample parameters
rhosSampled0 = sample(rhoEst, p)
rhosSampled0 = rhosSampled0/sum(rhosSampled0)
#For each population, modify a fraction TPR of the abundances (compensation is not so badly needed here, we do not test individual species). Record the taxa that have been modified.
rhosIDSampled = lapply(1:nPop, function(x, rhos){
  id = sample(seq_len(p), round(TPR*p))
  rhos[id] = rhos[id]*FC
  cbind(rhos = rhos/sum(rhos), id = id) #renormalize
}, rhos = rhosSampled0)

rhosSampled00 = sapply(rhosIDSampled, function(x){x[, "rhos"]})
rhosSampled = rhosSampled00[,groupInd]
IDsampled = sapply(rhosIDSampled, function(x){x[, "id"]})

thetaDM = AGdm$theta
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes

## Create dataset
dataMat = t(sapply(seq_along(libSizesSampled),function(i){Dirichlet.multinomial(libSizesSampled[i], shape = rhosSampled[,i]*(1-thetaDM)/thetaDM)}))
colnames(dataMat) = rownames(rhosSampled) 
rownames(dataMat) = groupFactorDM
dataMat = dataMat[rowSums(dataMat)>0,colSums(dataMat)>0]
list(dataMat = dataMat, libSizesSampled = libSizesSampled, rhosSampled = rhosSampled00, IDsampled = IDsampled)
})
save(datListDM,groupFactorDM, file = "RCMsim/datListDM.RData")
} else {load(file = "RCMsim/datListDM.RData")}

# Results
if(!file.exists(file = "RCMsim/resListDM.RData")){
  if(!file.exists("RCMsim/resListDMRCM.RData")){
RCMresListDM = mclapply(mc.cores=4, datListDM, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresListDM, file = "RCMsim/resListDMRCM.RData")
  } else {load("RCMsim/resListDMRCM.RData")}
  listID = sapply(RCMresListDM, class)=="RCM"
RCMresListDM = Filter(RCMresListDM, f = is.list)
resListDM = otherAnalyses(RCMresListDM, cores = 4)
IDlistDM = lapply( datListDM[listID], function(x){
  id = apply(x$IDsampled, 2, unique)
  taxa = apply(id, 2, function(y){rownames(x$rhosSampled)[y]})
  })
resListDMRows = lapply(resListDM, extractRows)
resListDMCols = mapply(resListDM, resListDMRows, FUN=extractCols, SIMPLIFY=FALSE)

datListDM = lapply(RCMresListDM, function(x){x$X})
SilDFDM = makeSilDf(resListDMRows, groupFactorDM)
CorDFDMlib = makeCorDf(resListDMRows, datListDM, scoreDim = "rows", dataMat = TRUE, groupMeth = groupsMeth)
CorDFDMtax = makeCorDf(resListDMCols, datListDM, scoreDim = "columns", dataMat = TRUE, groupMeth = groupsMeth)
distDFDM = makeDistDf(resListDMRows, groupFactorDM)
contrDM = contrTaxaWrap(resListDMRows, resListDMCols, IDlistDM, groupFactorDM)
rm(resListDMRows, resListDM, datListDM, resListDMCols);gc(verbose = FALSE)
save(CorDFDMlib, CorDFDMtax, SilDFDM, distDFDM, contrDM, file = "RCMsim/resListDM.RData")
} else {load(file = "RCMsim/resListDM.RData")}
```

### Nonparametric simulation

An objective simulation approach would be to use non-parametric resampling from a true dataset, as in _SimSeq_. For this we need microbiome datasets with covariates known to be related to bacterial abundance, preferably with more than two groups. The Zeller data is one such dataset, with the cancer variable expected to be related to relative abundance and having three levels (Normal, small adenoma and cancer). For the American Gut data we can use IBD. For the Turnbaugh lean and obese twins dataset we can use health status (lean, overweight or obese), even though we have only 18 samples. For the Turnbaugh humanized mouse dataset we could use "Diet", with levels "BK" and "Western".

We generate data as follows

1. Select a covariate and test for differential abundance using WMW/Kruskal-Wallis
2. Calculate local false discovery rates (lfdr)
3. Sample non DA taxa with equal weights from all taxa
4. Sample DA taxa from all taxa with weights equal to 1-lfdr
5. Sample counts from non DA taxa from samples with the most frequent covariate level
6. Sample counts from DA taxa also from the samples with other covariate levels, and correct for differences in library sizes. This maintains the same distribution of covariate levels and overal data matrix size as the original dataset. 

```{r simSeqAnalysis, purl = FALSE}
if(!file.exists("RCMsim/resListSimSeq.RData")){
  
  if(!file.exists(file = "SimSeqTests.RData")){
load("/home/stijn/PhD/Simulations/data/zellerData.RData")
load(file = "/home/stijn/PhD/Datasets/Humanized mouse/HumMicePhy.RData")
testHum = testSimSeq(HumMicePhy, "Diet")
load(file = "/home/stijn/PhD/Datasets/TurnbaughObeseTwins/TurnTwins.RData")
testTwins = testSimSeq(TurnTwins, "Status_p") # No significance
testAG = testSimSeq(AGphylo, "IBD")
testZeller = testSimSeq(zellerSphy, "Diagnosis")
save(testHum, testTwins, testAG, testZeller, file = "SimSeqTests.RData")
} else {load(file = "SimSeqTests.RData")}
  
  if(!file.exists(file = "SimSeqData.RData")){
NsimSimSeq = 100
HumSimSeqList = mclapply(mc.cores = 1, 1:NsimSimSeq, function(i){
  genSimSeq(testHum)
})
AGSimSeqList = mclapply(mc.cores = 1, 1:NsimSimSeq, function(i){
  genSimSeq(testAG)
})
ZellerSimSeqList = mclapply(mc.cores = 1, 1:NsimSimSeq, function(i){
  genSimSeq(testZeller)
})
save(HumSimSeqList, ZellerSimSeqList, AGSimSeqList, file = "SimSeqData.RData")
  } else {load(file = "SimSeqData.RData")}

if(!file.exists("RCMsim/resListSimSeqRCM.RData")){
RCMresListSimSeqHum = mclapply(mc.cores=4, HumSimSeqList, function(y){
  RCM(y$data, k = nDim, distribution = "NB")
  })
RCMresListSimSeqAG = mclapply(mc.cores=4, AGSimSeqList, function(y){
  RCM(y$data, k = nDim, distribution = "NB")
  })
RCMresListSimSeqZeller = mclapply(mc.cores=4, ZellerSimSeqList, function(y){
  RCM(y$data, k = nDim, distribution = "NB", round = TRUE)
  })
save(RCMresListSimSeqHum, RCMresListSimSeqAG, RCMresListSimSeqZeller, file = "RCMsim/resListSimSeqRCM.RData")
} else {load("RCMsim/resListSimSeqRCM.RData")}

resListSimSeqHum = otherAnalyses(RCMresListSimSeqHum, cores = 4)
rm(RCMresListSimSeqHum);gc(verbose = FALSE)
IDlistHum = mapply(HumSimSeqList,resListSimSeqHum, FUN =  function(y,x, test){
    taxa = y$DEtaxa[y$DEtaxa %in% colnames(x$RCM$X)]
    test[taxa,]
    }, SIMPLIFY = FALSE, MoreArgs = list(test = t(testHum$result)))
groupFactorHum = HumSimSeqList[[1]]$treatment
resListSimSeqHumRows = lapply(resListSimSeqHum, extractRows)
resListSimSeqHumCols = mapply(resListSimSeqHum, resListSimSeqHumRows, FUN=extractCols, SIMPLIFY=FALSE)

datListHum = lapply(RCMresListSimSeqHum, function(x){x$X})
SilDFHum = makeSilDf(resListSimSeqHumRows, groupFactorHum)
CorDFHumlib = makeCorDf(resListSimSeqHumRows, datListHum, scoreDim = "rows", dataMat = TRUE, groupMeth = groupsMeth)
CorDFHumtax = makeCorDf(resListSimSeqHumCols, datListHum, scoreDim = "columns", dataMat = TRUE, groupMeth = groupsMeth)
distDFHum = makeDistDf(resListSimSeqHumRows, groupFactorHum)
contrHum = contrTaxaWrap(resListSimSeqHumRows, resListSimSeqHumCols, IDlistHum, groupFactorHum, upDown = TRUE)
rm(resListSimSeqHumRows, resListHum, datListHum, resListSimSeqHumCols);gc(verbose = FALSE)

# Zeller
zellerID = sapply(RCMresListSimSeqZeller, class) == "RCM"
resListSimSeqZeller = otherAnalyses(RCMresListSimSeqZeller[zellerID], cores = 1)
IDlistZeller = mapply(ZellerSimSeqList[zellerID],RCMresListSimSeqZeller[zellerID], FUN =  function(y,x, test){
    taxa = y$DEtaxa[y$DEtaxa %in% colnames(x$X)]
    test[taxa,]
    }, SIMPLIFY = FALSE, MoreArgs = list(test = t(testZeller$result)))
groupFactorZeller = ZellerSimSeqList[[1]]$treatment
resListSimSeqZellerRows = lapply(resListSimSeqZeller, extractRows)
resListSimSeqZellerCols = mapply(resListSimSeqZeller, resListSimSeqZellerRows, FUN=extractCols, SIMPLIFY=FALSE)
datListZeller = lapply(RCMresListSimSeqZeller[zellerID], function(x){x$X})
SilDFZeller = makeSilDf(resListSimSeqZellerRows, groupFactorZeller)
CorDFZellerlib = makeCorDf(resListSimSeqZellerRows, datListZeller, scoreDim = "rows", dataMat = TRUE, groupMeth = groupsMeth)
CorDFZellertax = makeCorDf(resListSimSeqZellerCols, datListZeller, scoreDim = "columns", dataMat = TRUE, groupMeth = groupsMeth)
distDFZeller = makeDistDf(resListSimSeqZellerRows, groupFactorZeller)
contrZeller = contrTaxaWrap(resListSimSeqZellerRows, resListSimSeqZellerCols, IDlistZeller, groupFactorZeller, upDown = TRUE)
rm(resListSimSeqZellerRows, resListZeller, datListZeller, resListSimSeqZellerCols);gc(verbose = FALSE)

save(SilDFHum, CorDFHumlib, CorDFHumtax, distDFHum, contrHum, SilDFZeller, CorDFZellerlib, CorDFZellertax, distDFZeller, contrZeller, file = "RCMsim/resListSimSeq.RData")
} else {load("RCMsim/resListSimSeq.RData")}
```

# Simulation results

## Correlations with library sizes

Library sizes are considered to be technical artefacts, and thus should not affect the ordination, which is meant to display only biological signal. To verify this we calculate the correlations of the observed library sizes with every set of sample scores and compare this with the correlation with a random standard normal variable.

### Parametric simulation

```{r libCor0, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H0 in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCor0}"}
plotCor(CorDF0lib)
```

```{r libCor4, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H0, but with differences in dispersions between 4 sample groups, in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCor4}"}
plotCor(CorDF4lib)
```

```{r libCor1, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H1 with 4 unrelated sample groups in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCor1}"}
plotCor(CorDF1lib)
```

```{r libCor2, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCor2}"}
plotCor(CorDF2lib)
```

```{r libCor3, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and differences in library sizes in each group in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCor3}"}
plotCor(CorDF3lib)
```

```{r libCor5, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCor5}"}
plotCor(CorDF5lib)
```

```{r libCorPhy, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCorPhy}"}
plotCor(CorDFPhylib)
```

```{r libCorDM, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the Dirichlet multinomial distribution under H1 in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCorDM}"}
plotCor(CorDFDMlib)
```

```{r libCorZINB, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the zero-inflated negative binomial distribution under H1 in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCorZINB}"}
plotCor(CorDFZINBlib)
```

\clearpage

### Non-parametric simulation

```{r libCorHum, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 non-parametric simulations based on the Turnbaugh dataset in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCorHum}"}
plotCor(CorDFHumlib)
```

```{r libCorZeller, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 non-parametric simulations based on the Zeller dataset in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCorZeller}"}
plotCor(CorDFZellerlib)
```

\clearpage

## Sample separatation

### Silhouette

#### Parametric simulation

```{r sil1, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 unrelated sample groups. Orange diamonds indicate means.\\label{supfig:sil1}"}
plotSil(SilDF1)
```

```{r sil2, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:sil2}"}
plotSil(SilDF2)
```

```{r sil3, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and differences in library sizes in each group. Orange diamonds indicate means.\\label{supfig:sil3}"}
plotSil(SilDF3)
```

```{r sil5, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa. Orange diamonds indicate means.\\label{supfig:sil5}"}
plotSil(SilDF5)
```

```{r silPhy, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa. Orange diamonds indicate means.\\label{supfig:silPhy}"}
plotSil(SilDFPhy)
```

```{r silDM, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the Dirichlet multinomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:silDM}"}
plotSil(SilDFDM)
```

```{r silZINB, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the zero-inflated negative binomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:silZINB}"}
plotSil(SilDFZINB)
```

\clearpage

#### Non-parametric simulation

```{r silHum, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 non-parametric simulations based on the Turnbaugh data. Orange diamonds indicate means.\\label{supfig:silHum}"}
plotSil(SilDFHum)
```

```{r silZeller, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 non-parametric simulations based on the Zeller data. Orange diamonds indicate means.\\label{supfig:silZeller}"}
plotSil(SilDFZeller)
```

\clearpage

### Between-overall distance ratio

#### Parametric simulation

```{r dist1, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 unrelated sample groups. Orange diamonds indicate means.\\label{supfig:dist1}"}
distRatioPlot(distDF1)
```

```{r dist2, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:dist2}"}
distRatioPlot(distDF2)
```

```{r dist3, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and differences in library sizes in each group. Orange diamonds indicate means.\\label{supfig:dist3}"}
distRatioPlot(distDF3)
```

```{r dist5, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa. Orange diamonds indicate means.\\label{supfig:dist5}"}
distRatioPlot(distDF5)
```

```{r distPhy, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa. Orange diamonds indicate means. DPCoA and weighted Unifrac clearly profit from using the phylogenetic information\\label{supfig:distPhy}"}
distRatioPlot(distDFPhy)
```

```{r distDM, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the Dirichlet multinomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:distDM}"}
distRatioPlot(distDFDM)
```

```{r distZINB, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the zero-inflated negative binomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:distZINB}"}
distRatioPlot(distDFZINB)
```

\clearpage

#### Non-parametric simulation

```{r distHum, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 non-parametric simulations based on the Turnbaugh data. Orange diamonds indicate means.\\label{supfig:distHum}"}
distRatioPlot(distDFHum)
```

```{r distZeller, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 non-parametric simulations based on the Zeller data. Orange diamonds indicate means.\\label{supfig:distZeller}"}
distRatioPlot(distDFZeller)
```

\clearpage

## Taxon identification

#### Parametric simulation

```{r contr2, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:contr2}"}
contrPlot(contr2)
```

```{r contr3, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and differences in library sizes in each group. Orange diamonds indicate means.\\label{supfig:contr3}"}
contrPlot(contr3)
```

```{r contr5, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa. Orange diamonds indicate means.\\label{supfig:contr5}"}
contrPlot(contr5)
```

```{r contrPhy, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa. Orange diamonds indicate means. DPCoA and weighted Unifrac clearly profit from using the phylogenetic information\\label{supfig:contrPhy}"}
contrPlot(contrPhy)
```

```{r contrDM, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 simulations with the Dirichlet multinomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:contrDM}"}
contrPlot(contrDM)
```

```{r contrZINB, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 simulations with the zero-inflated negative binomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:contrZINB}"}
contrPlot(contrZINB)
```

\clearpage

#### Non-parametric simulation

```{r contrHum, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 non-parametric simulations based on the Turnbaugh data. Orange diamonds indicate means.\\label{supfig:contrHum}"}
contrPlot(contrHum)
```

```{r contrZeller, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 non-parametric simulations based on the Zeller data. Orange diamonds indicate means.\\label{supfig:contrZeller}"}
contrPlot(contrZeller)
```