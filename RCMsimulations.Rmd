---
title: "RCM simulations"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  pdf_document:
    includes:
      in_header: packagesRCM.sty
---

```{r setup, warning=FALSE, message=FALSE, echo=FALSE, purl=TRUE}
WD = "/home/stijn/PhD/Biplots"
knitr::opts_knit$set(root.dir = WD)
knitr::opts_chunk$set(cache = TRUE, autodep = TRUE,  warning = FALSE, message=FALSE, echo=FALSE, eval=TRUE, tidy = TRUE, fig.width = 9, fig.height=6, purl=TRUE, fig.show = "hold", cache.lazy = FALSE)
# The required package list:
reqpkg <- c("phyloseq", "parallel", "ggplot2", "vegan", "reshape2") #"DirFactor","MASS",
# Load all required packages and show version
for(i in reqpkg)
{
#   print(i) 
#   print(packageVersion(i))
  library(i, quietly = TRUE, verbose = FALSE, warn.conflicts = FALSE, character.only = TRUE)
} 
if(detectCores()==4) setwd(WD)
par(pty="s", mar = c(8,2,4,2), cex.main = 0.9) #Make sure the biplots are square!
palStore = grep("black",palette(), value =TRUE, invert = TRUE)
palette(palStore)
levelsMeth = c("CApearson","CAcontRat","CAchisq","DCA", "Hellinger","DPCOA","BC","BCrel","BCrelNMDS", "JSD","UniFrac","wUniFrac", "CoDa","RCM", "Control")
labelsMeth = c("CApearson","CAcontRat","CAchisq","DCA","Hellinger","DPCOA","Bray-Curtis-Abs","Bray-Curtis","Bray-Curtis NMDS", "JSD","UniFrac","weighted UniFrac","CoDa","RCM", "Control")
groupsMeth = factor(c("Independence","Independence","Independence","Independence","Independence","Distance","Distance","Distance","Distance","Distance","Distance","Distance", "CoDa", "RCM"), levels = c("Independence", "Distance", "CoDa", "RCM"), ordered = TRUE)
names(groupsMeth) = grep(levelsMeth, value  = TRUE, pattern ="Control", invert = TRUE)
factorMeth = factor(levelsMeth, levels = levelsMeth, labels = labelsMeth)
borderCol = "black"
funFiles = dir("R")
funFilesPub = dir("pubFun")
for (i in funFiles) {source(file.path("R",i))}
for (i in funFilesPub) {source(file.path("pubFun",i))};rm(i)
# load("/home/stijn/PhD/American Gut/AGphylo.RData")
load("/home/stijn/PhD/Simulations/data/physeqListV13.RData")
load("/home/stijn/PhD/Simulations/data/MLES.RData") #Load observed parameter values
```

# Simulation setup

## Unconstrained RC(M)

As ways of generating test datasets we see three different options

  1) Parametric simulation with the negative binomial with known abundances. 
  2) Non-parametric simulation with SimSeq
  3) Real datasets with biological signal allegedly known
  
  Parametric simulation is needed as a first check but evidently favours our method (if we use the negative binomial distribution). SimSeq is a reasonably neutral tool, we will only use WMW to obtain the lfdr. Real datasets will need to complement our analysis but it may not be possible to evaluate them in a high-throughput way, this will need to happen empirically.
  
### Parametric simulations

#### Negative binomial

The negative binomial is the assumed distribution of our method. As a result we should outperform all other methods in this setting.

\clearpage

##### Null setting

In this setting we simulate all distributions from the same template, thus there is no signal in this dataset

```{r NBnull, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions
rhoEst = unlist(rhoMLEs) #observed relative abundances, pooled
thetaEst = 1/unlist(phiMLEs) #observed dispersions abundances, pooled

#Library sizes
libSizesEst = unlist(sapply(physeqListV13, sample_sums)) #Resample
if(!file.exists(file = "RCMsim/resList0.RData")){
  if(!file.exists(file = "RCMsim/datList0.RData")){
datList0 = mclapply(mc.cores=1, integer(reps), function(i){
## Sample parameters
rhosSampled = sample(rhoEst, p)
thetasSampled = sample(thetaEst, p) #Sampled dispersions are the same in every population, this is the ideal case assumed by our method.
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes
## Create dataset
meanMat = outer(libSizesSampled, rhosSampled)
dataMat = matrix(rnbinom(prod(dim(meanMat)), mu = meanMat, size = matrix(thetasSampled,n,p,byrow = TRUE)),n,p)
rownames(dataMat) = names(libSizesSampled) = seq_len(n)
colnames(dataMat) = names(rhosSampled) = names(thetasSampled) = seq_len(p)
rowID = rowSums(dataMat)>0
colID = colSums(dataMat)>0
list(dataMat = dataMat[rowID, colID], libSizesSampled = libSizesSampled[rowID], thetasSampled = thetasSampled[colID], rhosSampled = rhosSampled[colID])
})
save(datList0,  file = "RCMsim/datList0.RData")
} else {load(file = "RCMsim/datList0.RData")}

# Results
  if(!file.exists("RCMsim/resList0RCM.RData")){
RCMresList0 = mclapply(mc.cores=4, datList0, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList0, file = "RCMsim/resList0RCM.RData")
} else {load("RCMsim/resList0RCM.RData")}
  if(!file.exists("RCMsim/resList0OA.RData")){
resList0 = otherAnalyses(RCMresList0, cores = 1)
save(resList0, file = "RCMsim/resList0OA.RData")
} else {load("RCMsim/resList0OA.RData")}
resList0Rows = lapply(resList0, extractRows)
resList0Cols = mapply(resList0, resList0Rows, FUN=extractCols, SIMPLIFY=FALSE)
CorDF0lib = makeCorDf(resList0Rows, datList0, scoreDim = "rows", groupMeth = groupsMeth)
CorDF0tax = makeCorDf(resList0Cols, datList0, scoreDim = "columns", groupMeth = groupsMeth)
CorDF0disp = makeCorDf(resList0Cols, datList0, scoreDim = "dispersions", groupMeth = groupsMeth)
rm(resList0Rows, resList0, datList0, resList0Cols);gc(verbose = FALSE)
save(CorDF0lib, CorDF0tax,CorDF0disp, file = "RCMsim/resList0.RData")
} else {load(file = "RCMsim/resList0.RData")}
rm(physeqListV13);gc(verbose = FALSE)
```

```{r Starting Values, purl = FALSE, eval = FALSE, echo = FALSE}
startList= lapply(resList0, startFun)
moltStart = melt(startList, value.name = "correlation")
names(moltStart) = c("correlation", "scores","run")
boxplot(correlation ~ scores, data = moltStart, las=2)
abline(h=0, col ="red", lty = "dashed")
#Squared weighing clearly gives the best results, although no fantastic correlations.
```

\clearpage

##### Null setting, different library sizes

In this setting we simulate all distributions from the same template, but with ten-fold differences in library sizes. Stiill there is thus no signal in this dataset.

```{r NBnullb, purl = FALSE}
groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactor0b = factor(groupInd, levels = 1:nPop, labels =  c("1", "1.5","2","3"), ordered = TRUE) #as factor
if(!file.exists(file = "RCMsim/resList0b.RData")){
  if(!file.exists(file = "RCMsim/datList0b.RData")){
datList0b = mclapply(mc.cores = 4, 1:reps, function(i){
## Sample parameters
rhosSampled = sample(rhoEst, p)
thetasSampled = sample(thetaEst, p) #Sampled dispersions are the same in every population, this is the ideal case assumed by our method.
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes, confounded with group membership
libSizesSampled[groupInd==2] = round(libSizesSampled[groupInd==2]*1.5)
libSizesSampled[groupInd==3] = round(libSizesSampled[groupInd==3]*2)
libSizesSampled[groupInd==4] = round(libSizesSampled[groupInd==4]*3)

## Create dataset
meanMat = outer(libSizesSampled, rhosSampled)
dataMat = matrix(rnbinom(prod(dim(meanMat)), mu = meanMat, size = matrix(thetasSampled,n,p,byrow = TRUE)),n,p)
rownames(dataMat) = names(libSizesSampled) = seq_len(n)
colnames(dataMat) = names(rhosSampled) = names(thetasSampled) = seq_len(p)
rowID = rowSums(dataMat)>0
colID = colSums(dataMat)>0
list(dataMat = dataMat[rowID, colID], libSizesSampled = libSizesSampled[rowID], thetasSampled = thetasSampled[colID], rhosSampled = rhosSampled[colID])
})
save(datList0b,  file = "RCMsim/datList0b.RData")
} else {load(file = "RCMsim/datList0b.RData")}
# Results
  if(!file.exists("RCMsim/resList0RCMb.RData")){
RCMresList0b = mclapply(mc.cores=4, datList0b, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList0b, file = "RCMsim/resList0RCMb.RData")
  } else { load("RCMsim/resList0bRCM.RData")}
RCMresList0b = RCMresList0b[sapply(RCMresList0b, class) == "RCM"]
if(!file.exists("RCMsim/resList0bOA.RData")){
resList0b = otherAnalyses(RCMresList0b, cores = 4)
save(resList0b, file = "RCMsim/resList0bOA.RData")
} else {load("RCMsim/resList0bOA.RData")}
resList0bRows = lapply(resList0b, extractRows)
resList0bCols = mapply(resList0b, resList0bRows, FUN=extractCols, SIMPLIFY=FALSE)

datList0b = lapply(RCMresList0b, function(x){x$X})
CorDF0blib = makeCorDf(resList0bRows, datList0b, scoreDim = "rows", groupMeth = groupsMeth)
CorDF0btax = makeCorDf(resList0bCols, datList0b, scoreDim = "columns", groupMeth = groupsMeth)
#We also want to see if they cluster according to library sizes
SilDF0b = makeSilDf(resList0bRows, groupFactor0b)
distDF0b = makeDistDf(resList0bRows, groupFactor0b)
rm(resList0bRows, resList0b, datList0b, resList0bCols);gc(verbose = FALSE)
save(CorDF0blib, CorDF0btax, SilDF0b, distDF0b, file = "RCMsim/resList0b.RData")
} else {load(file = "RCMsim/resList0b.RData")}
```

##### Simulate under H0, but with differences in dispersion

Inspired by Warton _et al._ (2012): "Distance-based multivariate analyses confound location and dispersion effects" we set up a simulation without any signal, but whereby the dispersions in the different groups are different, as a result of the group effect itself or related sampling effects. Note that this also violates the assumption of our RC(M) method of constant dispersions.

```{r NBdispsersion, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactor4 = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor
if(!file.exists(file = "RCMsim/resList4.RData")){
  if(!file.exists(file = "RCMsim/datList4.RData")){
datList4 = mclapply(mc.cores = 4, 1:reps, function(i){
## Sample parameters
rhosSampled = sample(rhoEst, p)
thetasSampled = sample(thetaEst, p) 
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes
#Sampled dispersions differ between the population
thetaMat = matrix(thetasSampled, n, p, byrow = TRUE) * c(rep(c(0.2,0.5,1,5), eac = nPerPop)) #Modify dispersions to 5 times, 2 times and 0.2 times the normal levels

## Create dataset
meanMat = outer(libSizesSampled, rhosSampled)
dataMat = matrix(rnbinom(prod(dim(meanMat)), mu = meanMat, size = thetaMat),n,p)
rownames(dataMat) = names(libSizesSampled) = seq_len(n)
colnames(dataMat) = names(rhosSampled) = names(thetasSampled) = seq_len(p)
list(dataMat = dataMat, libSizesSampled = libSizesSampled[rowID], thetasSampled = thetasSampled[colID], rhosSampled = rhosSampled[colID])})
save(datList4, groupFactor4, file = "RCMsim/datList4.RData")
} else {load(file = "RCMsim/datList4.RData")}

# Results
  if(!file.exists("RCMsim/resList4RCM.RData")){
RCMresList4 = mclapply(mc.cores=4, datList4, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList4, file = "RCMsim/resList4RCM.RData")
} else {load("RCMsim/resList4RCM.RData")}
  if(!file.exists("RCMsim/resList4OA.RData")){
resList4 = otherAnalyses(RCMresList4, cores = 4)
save(resList4, file = "RCMsim/resList4OA.RData")
} else {load("RCMsim/resList1OA.RData")}
resList4Rows = lapply(resList4, extractRows)
resList4Cols = mapply(resList4, resList4Rows, FUN = extractCols, SIMPLIFY = FALSE)

datList4 = lapply(RCMresList4, function(x){x$X})
CorDF4lib = makeCorDf(resList4Rows, datList4, scoreDim = "rows", groupMeth = groupsMeth)
CorDF4tax = makeCorDf(resList4Cols, datList4, scoreDim = "columns", groupMeth = groupsMeth)
SilDF4 = makeSilDf(resList4Rows, groupFactor4)
distDF4 = makeDistDf(resList4Rows, groupFactor4)
rm(resList4Rows, resList4, datList4, SilDF4, distDF4, resList4Cols);gc(verbose = FALSE)
save(CorDF4lib, CorDF4tax, SilDF4, distDF4, file = "RCMsim/resList4.RData")
} else {load(file = "RCMsim/resList4.RData")}
```

\clearpage

##### Simulate from different distributions

In this setting we will simulate data from 4 unrelated negative binomial distributions. Because of this clustering should be very good.

```{r NBunrelatedDistr, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactor1 = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor

if(!file.exists(file = "RCMsim/resList1.RData")){
  if(!file.exists(file = "RCMsim/datList1.RData")){
datList1 = mclapply(mc.cores=1, 1:reps, function(i){
## Sample parameters
rhosSampled = sapply(1:nPop, function(x){tmp=sample(rhoEst, p); tmp/sum(tmp)})[,groupInd]
thetasSampled = sample(thetaEst, p) #Sampled dispersions are the same in every population, this is the ideal case assumed by our method.
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes

## Create dataset
meanMat = libSizesSampled * t(rhosSampled)
dataMat = matrix(rnbinom(prod(dim(meanMat)), mu = meanMat, size = matrix(thetasSampled,n,p, byrow = TRUE)),n,p)
rownames(dataMat) = names(libSizesSampled) = seq_len(n)
colnames(dataMat) = names(rhosSampled) = names(thetasSampled) = seq_len(p)
rowID = rowSums(dataMat)>0
colID = colSums(dataMat)>0
list(dataMat = dataMat[rowID, colID], libSizesSampled = libSizesSampled[rowID], thetasSampled = thetasSampled[colID])
})
save(datList1,groupFactor1,  file = "RCMsim/datList1.RData")
} else {load(file = "RCMsim/datList1.RData")}

# Results

  if(!file.exists("RCMsim/resList1RCM.RData")){
RCMresList1 = mclapply(mc.cores = 4, datList1, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList1, file = "RCMsim/resList1RCM.RData")
  } else {load("RCMsim/resList1RCM.RData")}
  if(!file.exists("RCMsim/resList1OA.RData")){
resList1 = otherAnalyses(RCMresList1, cores = 4)
save(resList1, file = "RCMsim/resList1OA.RData")
} else {load("RCMsim/resList1OA.RData")}
resList1Rows = lapply(resList1, extractRows)
resList1Cols = mapply(resList1, resList1Rows,FUN = extractCols, SIMPLIFY = FALSE)
SilDF1 = makeSilDf(resList1Rows, groupFactor1)
datList1 = lapply(RCMresList1, function(x){x$X})
CorDF1lib = makeCorDf(resList1Rows, datList1, scoreDim = "rows", groupMeth = groupsMeth)
CorDF1tax = makeCorDf(resList1Cols, datList1, scoreDim = "columns", groupMeth = groupsMeth)
distDF1 = makeDistDf(resList1Rows, groupFactor1)
save(CorDF1lib, CorDF1tax, SilDF1, distDF1, file = "RCMsim/resList1.RData")
rm(resList1Rows, resList1, datList1, resList1Cols);gc(verbose = FALSE)
} else {load(file = "RCMsim/resList1.RData")}
```

##### Simulate from related distributions

In this setting we will simulate data from 4 related negative binomial distributions, all obtained from the same mother distributions but 10\% of the taxa have modified abundances

```{r NBrelatedDistr, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions
TPR = 0.1
FC = 5

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactor2 = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor
if(!file.exists(file = "RCMsim/resList2.RData")){
  if(!file.exists(file = "RCMsim/datList2.RData")){
datList2 = mclapply(mc.cores = 1, 1:reps, function(i){
## Sample parameters
rhosSampled0 = sample(rhoEst, p)
rhosSampled0 = rhosSampled0/sum(rhosSampled0)
#For each population, modify a fraction TPR of the abundances (compensation is not so badly needed here, we do not test individual species). Record the taxa that have been modified.
rhosIDSampled = lapply(1:nPop, function(x, rhos){
  id = sample(seq_len(p), round(TPR*p))
  rhos[id] = rhos[id]*FC
  cbind(rhos = rhos/sum(rhos), id = id) #renormalize
}, rhos = rhosSampled0)

rhosSampled00 = sapply(rhosIDSampled, function(x){x[, "rhos"]})
rhosSampled = rhosSampled00[,groupInd]
IDsampled = sapply(rhosIDSampled, function(x){x[, "id"]})

thetasSampled = sample(thetaEst, p) 
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes

## Create dataset
meanMat = libSizesSampled * t(rhosSampled)
dataMat = matrix(rnbinom(prod(dim(meanMat)), mu = meanMat, size = matrix(thetasSampled,n,p,byrow = TRUE)),n,p)
colnames(dataMat) = rownames(rhosSampled) 
rownames(dataMat) = groupFactor2
rowID = rowSums(dataMat)>0
colID = colSums(dataMat)>0
dataMat = dataMat[rowID, colID]
list(dataMat = dataMat, libSizesSampled = libSizesSampled[rowID], thetasSampled = thetasSampled[colID], rhosSampled = rhosSampled00[colID,])
})
save(datList2,groupFactor2,  file = "RCMsim/datList2.RData")
} else {load(file = "RCMsim/datList2.RData")}

# Results

  if(!file.exists("RCMsim/resList2RCM.RData")){
RCMresList2 = mclapply(mc.cores=4, datList2, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList2, file = "RCMsim/resList2RCM.RData")
} else {load("RCMsim/resList2RCM.RData")}
  if(!file.exists("RCMsim/resList2OA.RData")){
resList2 = otherAnalyses(RCMresList2, cores = 4)
save(resList2, file = "RCMsim/resList2OA.RData")
} else {load("RCMsim/resList2OA.RData")}
IDlist2 = lapply(datList2, function(x){
   id = apply(x$IDsampled, 2, unique)
   taxa = apply(id, 2, function(y){rownames(x$rhosSampled)[y]})
   })
resList2Rows = lapply(resList2, extractRows)
resList2Cols = mapply(resList2, resList2Rows,FUN = extractCols, SIMPLIFY = FALSE)

datList2 = lapply(RCMresList2, function(x){x$X})
SilDF2 = makeSilDf(resList2Rows, groupFactor2)
CorDF2lib = makeCorDf(resList2Rows, datList2, scoreDim = "rows", groupMeth = groupsMeth)
CorDF2tax = makeCorDf(resList2Cols, datList2, scoreDim = "columns", groupMeth = groupsMeth)
CorDF2disp = makeCorDf(resList2Cols, datList2, scoreDim = "columns", groupMeth = groupsMeth, dispersion = TRUE)
distDF2 = makeDistDf(resList2Rows, groupFactor2)
contr2 = contrTaxaWrap(resList2Rows, resList2Cols, IDlist2, groupFactor2)
rm(resList2Rows, resList2, datList2, resList2Cols, IDlist2);gc(verbose = FALSE)
save(CorDF2lib, CorDF2tax, SilDF2, distDF2, contr2, file = "RCMsim/resList2.RData")
} else {load(file = "RCMsim/resList2.RData")}
```

\clearpage

##### Simulate from related distributions, confounded by library sizes

In this setting we will again simulate data from 4 related negative binomial distributions, all obtained from the same mother distributions but 10\% of the taxa have modified abundances. In this case we will make the library sizes different in each group. Th initial library sizes are all sampled from the same pool of library sizes observed in real data. The first group has unmodified library sizes, the second group library sizes multiplied by 1.5, the third by 2 and the fourth by 3.

```{r NBrelatedDistrConf, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions
TPR = 0.1
FC = 5

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactor3 = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor
if(!file.exists(file = "RCMsim/resList3.RData")){
  if(!file.exists(file = "RCMsim/datList3.RData")){
datList3 = mclapply(mc.cores = 1, 1:reps, function(i){
## Sample parameters
rhosSampled0 = sample(rhoEst, p)
rhosSampled0 = rhosSampled0/sum(rhosSampled0)
#For each population, modify a fraction TPR of the abundances (compensation is not so badly needed here, we do not test individual species). Record the taxa that have been modified.
rhosIDSampled = lapply(1:nPop, function(x, rhos){
  id = sample(seq_len(p), round(TPR*p))
  rhos[id] = rhos[id]*FC
  cbind(rhos = rhos/sum(rhos), id = id) #renormalize
}, rhos = rhosSampled0)

rhosSampled00 = sapply(rhosIDSampled, function(x){x[, "rhos"]})
rhosSampled = rhosSampled00[,groupInd]
IDsampled = sapply(rhosIDSampled, function(x){x[, "id"]})

thetasSampled = sample(thetaEst, p) 
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes, confounded with group membership
libSizesSampled[groupInd==2] = round(libSizesSampled[groupInd==2]*1.5)
libSizesSampled[groupInd==3] = round(libSizesSampled[groupInd==3]*2)
libSizesSampled[groupInd==4] = round(libSizesSampled[groupInd==4]*3)

## Create dataset
meanMat = libSizesSampled * t(rhosSampled)
dataMat = matrix(rnbinom(prod(dim(meanMat)), mu = meanMat, size = matrix(thetasSampled,n,p,byrow = TRUE)),n,p)
colnames(dataMat) = rownames(rhosSampled) 
rownames(dataMat) = groupFactor3
rowID = rowSums(dataMat)>0
colID = colSums(dataMat)>0
dataMat = dataMat[rowID, colID]
list(dataMat = dataMat, libSizesSampled = libSizesSampled[rowID], thetasSampled = thetasSampled[colID], rhosSampled = rhosSampled00[colID,])})
save(datList3,groupFactor3,  file = "RCMsim/datList3.RData")
} else {load(file = "RCMsim/datList3.RData")}

# Results
  if(!file.exists("RCMsim/resList3RCM.RData")){
RCMresList3 = mclapply(mc.cores=4, datList3, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList3, file = "RCMsim/resList3RCM.RData")
} else {load("RCMsim/resList3RCM.RData")}
  if(!file.exists("RCMsim/resList3OA.RData")){
resList3 = otherAnalyses(RCMresList3, cores = 4)
save(resList3, file = "RCMsim/resList3OA.RData")
} else {load("RCMsim/resList3OA.RData")}

IDlist3 = lapply(datList3, function(x){
   id = apply(x$IDsampled, 2, unique)
   taxa = apply(id, 2, function(y){rownames(x$rhosSampled)[y]})
   })
resList3Rows = lapply(resList3, extractRows)
resList3Cols = mapply(resList3, resList3Rows,FUN = extractCols, SIMPLIFY = FALSE)

datList3 = lapply(RCMresList3, function(x){x$X})
SilDF3 = makeSilDf(resList3Rows, groupFactor3)
CorDF3lib = makeCorDf(resList3Rows, datList3, scoreDim = "rows", groupMeth = groupsMeth)
CorDF3tax = makeCorDf(resList3Cols, datList3, scoreDim = "columns", groupMeth = groupsMeth)
distDF3 = makeDistDf(resList3Rows, groupFactor3)
contr3 = contrTaxaWrap(resList3Rows, resList3Cols, IDlist3, groupFactor3)
rm(resList3Rows, resList3, datList3, resList3Cols);gc(verbose = FALSE)
save(CorDF3lib, CorDF3tax, SilDF3, distDF3, contr3, file = "RCMsim/resList3.RData")
} else {load(file = "RCMsim/resList3.RData")}
```

##### Simulate under H1, with correlated taxa

We know that taxa living in the same niche are dependent on each other, and as a result their abundances are correlated. This phenomenon can affect the differentialn abundance detection, so it could also affect our visualization procedures. I would also expect it to have an effect on the CoDa method, which relies on ratios between taxa of the same sample. We'll use the correlation networks previously estimated from the HMP and AGP datasets.

```{r NBrelatedDistrCorr, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions
TPR = 0.1
FC = 5

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactor5 = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor
if(!file.exists(file = "RCMsim/resList5.RData")){
  if(!file.exists(file = "RCMsim/datList5.RData")){
    load("/home/stijn/PhD/Simulations/data/covList.RData")
    require(SpiecEasi)
datList5 = mclapply(mc.cores = 1, 1:reps, function(i){
## Sample parameters
rhosSampled0 = sample(rhoEst, p)
rhosSampled0 = rhosSampled0/sum(rhosSampled0)
#For each population, modify a fraction TPR of the abundances (compensation is not so badly needed here, we do not test individual species). Record the taxa that have been modified.
rhosIDSampled = lapply(1:nPop, function(x, rhos){
  id = sample(seq_len(p), round(TPR*p))
  rhos[id] = rhos[id]*FC
  cbind(rhos = rhos/sum(rhos), id = id) #renormalize
}, rhos = rhosSampled0)

rhosSampled00 = sapply(rhosIDSampled, function(x){x[, "rhos"]})
rhosSampled = rhosSampled00[,groupInd]
IDsampled = sapply(rhosIDSampled, function(x){x[, "id"]})

thetasSampled = sample(thetaEst, p) 
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes, confounded with group membership
covMatName = sample(names(covList), 1)

## Create dataset
meanMat = libSizesSampled * t(rhosSampled)

dataMat = rmvnegbin(n = n,mu = meanMat, ks = thetasSampled, Sigma = as.matrix(covList[[covMatName]]))
colnames(dataMat) = rownames(rhosSampled) 
rownames(dataMat) = groupFactor5
rowID = rowSums(dataMat)>0
colID = colSums(dataMat)>0
dataMat = dataMat[rowID, colID]
list(dataMat = dataMat, libSizesSampled = libSizesSampled[rowID], thetasSampled = thetasSampled[colID], rhosSampled = rhosSampled00[colID,])})
save(datList5,groupFactor5,  file = "RCMsim/datList5.RData")
rm(covList);gc(verbose = FALSE)
} else {load(file = "RCMsim/datList5.RData")}

# Results
  if(!file.exists("RCMsim/resList5RCM.RData")){
RCMresList5 = mclapply(mc.cores=4, datList5, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresList5, file = "RCMsim/resList5RCM.RData")
} else {load("RCMsim/resList5RCM.RData")}
  if(!file.exists("RCMsim/resList5OA.RData")){
resList5 = otherAnalyses(RCMresList5, cores = 4)
save(resList5, file = "RCMsim/resList5OA.RData")
} else {load("RCMsim/resList5OA.RData")}
IDlist5 = lapply(datList5, function(x){
   id = apply(x$IDsampled, 2, unique)
   taxa = apply(id, 2, function(y){rownames(x$rhosSampled)[y]})
   })
resList5Rows = lapply(resList5, extractRows)
resList5Cols = mapply(resList5, resList5Rows,FUN = extractCols, SIMPLIFY = FALSE)

datList5 = lapply(resList5, function(x){x$RCM$X})
SilDF5 = makeSilDf(resList5Rows, groupFactor5)
CorDF5lib = makeCorDf(resList5Rows, datList5, scoreDim = "rows", groupMeth = groupsMeth)
CorDF5tax = makeCorDf(resList5Cols, datList5, scoreDim = "columns", groupMeth = groupsMeth)
distDF5 = makeDistDf(resList5Rows, groupFactor5)
contr5 = contrTaxaWrap(resList5Rows, resList5Cols, IDlist5, groupFactor5)
rm(resList5Rows, resList5, datList5, resList5Cols);gc(verbose = FALSE)
save(CorDF5lib, CorDF5tax, SilDF5, distDF5, contr5, file = "RCMsim/resList5.RData")
} else {load(file = "RCMsim/resList5.RData")}
```

##### Negative binomial with phylogenetic information

In order to also include the very popular distance measures UniFrac and weighted UniFrac, we also generate data with the negative binomial and Dirichlet multinomial taking into account phylogenetic structure. We base our strategy on the second strategy described by Chen _et al._ ("Associating microbiome composition with environmental
covariates using generalized UniFrac distances", 2012). We generate random trees for the template vector of relative abundances, and modify abundances within one of the 20 clusters.

```{r UniFrac, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions
TPR = 0.1
FC = 5
k = round(1/TPR) #Number of clusters

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactorPhy = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor

clusters = seq_len(k)

if(!file.exists(file = "RCMsim/resListPhy.RData")){
  if(!file.exists(file = "RCMsim/datListPhy.RData")){
    require(ape)
    require(cluster)
datListPhy = mclapply(mc.cores = 4, 1:reps, function(i){
## Sample parameters
cluSampled = sample(clusters, nPop) #Cluster to be made DA

rhosSampled0 = sample(rhoEst, p)
rhosSampled0 = rhosSampled0/sum(rhosSampled0)

randomTree = rcoal(n = p, tip.label = names(rhosSampled0)) # The random tree, use rcoal to make it ultrametric
psclust = cutree(as.hclust(randomTree), k = k) #Split into clusters
names(psclust) = randomTree$tip.label #Assign names
psclust = psclust[names(rhosSampled0)] #Reorder according to the rhos

#For each population, modify the abundances of a cluster of related taxa. Record the clusters that have been modified.
rhosIDSampled = lapply(cluSampled, function(x, rhos){
  id = x == psclust
  rhos[id] = rhos[id]*FC
  cbind(rhos = rhos/sum(rhos), id = id) #renormalize
}, rhos = rhosSampled0)

rhosSampled00 = sapply(rhosIDSampled, function(x){x[, "rhos"]})
rhosSampled = rhosSampled00[,groupInd]
IDsampled = sapply(rhosIDSampled, function(x){x[, "id"]})

thetasSampled = sample(thetaEst, p) 
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes

## Create dataset
meanMat = libSizesSampled * t(rhosSampled)
dataMat = matrix(rnbinom(prod(dim(meanMat)), mu = meanMat, size = matrix(thetasSampled,n,p,byrow = TRUE)),n,p)
colnames(dataMat) = rownames(rhosSampled) 
rownames(dataMat) = groupFactorPhy
rowID = rowSums(dataMat)>0
colID = colSums(dataMat)>0
dataMat = dataMat[rowID, colID]
list(dataMat = dataMat, libSizesSampled = libSizesSampled[rowID], thetasSampled = thetasSampled[colID], rhosSampled = rhosSampled00[colID,], IDsampled = IDsampled[colID,], cluSampled = cluSampled, randomTree = randomTree)
})
save(datListPhy, groupFactorPhy, file = "RCMsim/datListPhy.RData")
} else {load(file = "RCMsim/datListPhy.RData")}

# Results
 if(!file.exists("RCMsim/resListPhyRCM.RData")){
RCMresListPhy = mclapply(mc.cores=4, datListPhy, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresListPhy, file = "RCMsim/resListPhyRCM.RData")
  } else {load("RCMsim/resListPhyRCM.RData")}
listID = sapply(RCMresListPhy, is.list)

  if(!file.exists("RCMsim/resListPhyOA.RData")){
resListPhy = otherAnalyses(RCMresListPhy[listID], unifrac = TRUE, treeList = lapply(datListPhy[listID], function(x){x$randomTree}), cores = 4 )
save(resListPhy, file = "RCMsim/resListPhyOA.RData")
  } else {load("RCMsim/resListPhyOA.RData")}

IDlistPhy = lapply(datListPhy[listID], function(x){
   taxa = lapply(seq_len(ncol(x$IDsampled)), function(y){rownames(x$rhosSampled)[as.logical(x$IDsampled[,y])]})
   })
resListPhyRows = lapply(resListPhy, extractRows)
resListPhyCols = mapply(resListPhy, resListPhyRows,FUN = extractCols, SIMPLIFY = FALSE)

datListPhy = lapply(RCMresListPhy, function(x){x$X})
SilDFPhy = makeSilDf(resListPhyRows, groupFactorPhy)
CorDFPhylib = makeCorDf(resListPhyRows, datListPhy, scoreDim = "rows", groupMeth = groupsMeth)
CorDFPhytax = makeCorDf(resListPhyCols, datListPhy, scoreDim = "columns", groupMeth = groupsMeth)
distDFPhy = makeDistDf(resListPhyRows, groupFactorPhy)
contrPhy = contrTaxaWrap(resListPhyRows, resListPhyCols, IDlistPhy, groupFactorPhy)
rm(resListPhyRows, resListPhy, datListPhy, resListPhyCols);gc(verbose = FALSE)
save(CorDFPhylib, CorDFPhytax, SilDFPhy, distDFPhy, contrPhy, file = "RCMsim/resListPhy.RData")
} else {load(file = "RCMsim/resListPhy.RData")}
```

#### Other distributions

We also simulate datasets from other distributions than the negative binomial to see how the method behaves when its distributional assumptions are violated.

##### Zero-inflated negative binomial distribution

The zero-inflated negative binomial (ZINB) distribution was used by Zhang _et al._ (2016) for differential abundance testing. Our own goodness-of-fit tests indicate that for 14\% of the taxa, the ZINB provides a better fit than the regular NB

```{r simZINB}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions
TPR = 0.1
FC = 5

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactorZINB = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor

if(!file.exists(file = "RCMsim/resListZINB.RData")){
load(file="/home/stijn/PhD/Biplots/Zicoef.RData")

if(!file.exists(file = "RCMsim/datListZINB.RData")){
  require(VGAM)
datListZINB = mclapply(mc.cores=1, 1:reps, function(i){
## Sample parameters
rhosSampled0 = sample(rhoEst, p)
rhosSampled0 = rhosSampled0/sum(rhosSampled0)
#For each population, modify a fraction TPR of the abundances (compensation is not so badly needed here, we do not test individual species). Record the taxa that have been modified.
rhosIDSampled = lapply(1:nPop, function(x, rhos){
  id = sample(seq_len(p), round(TPR*p))
  rhos[id] = rhos[id]*FC
  cbind(rhos = rhos/sum(rhos), id = id) #renormalize
}, rhos = rhosSampled0)

rhosSampled00 = sapply(rhosIDSampled, function(x){x[, "rhos"]})
rhosSampled = rhosSampled00[,groupInd]
IDsampled = sapply(rhosIDSampled, function(x){x[, "id"]})

thetasSampled = sample(thetaEst, p) 
propSampled = expit(sample(ZIcoef, p))
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes

## Create dataset
meanMat = libSizesSampled * t(rhosSampled)
dataMat = matrix(rzinegbin(prod(dim(meanMat)), munb = meanMat, size = matrix(thetasSampled,n,p, byrow = TRUE), pstr0 = matrix(propSampled,n,p,byrow = TRUE)),n,p)
colnames(dataMat) = rownames(rhosSampled) 
rownames(dataMat) = groupFactorZINB
rowID = rowSums(dataMat)>0
colID = colSums(dataMat)>0
dataMat = dataMat[rowID, colID]
list(dataMat = dataMat, libSizesSampled = libSizesSampled[rowID], thetasSampled = thetasSampled[colID], rhosSampled = rhosSampled00[colID,], IDsampled = IDsampled[colID,], propSampled = propSampled[colID])
})
save(datListZINB,groupFactorZINB,  file = "RCMsim/datListZINB.RData")
} else {load(file = "RCMsim/datListZINB.RData")}

# Results

 if(!file.exists("RCMsim/resListZINBRCM.RData")){
RCMresListZINB = mclapply(mc.cores=4, datListZINB, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
save(RCMresListZINB, file = "RCMsim/resListZINBRCM.RData")
 } else {load("RCMsim/resListZINBRCM.RData")}
  
 if(!file.exists("RCMsim/resListZINBOA.RData")){
resListZINB = otherAnalyses(RCMresListZINB, cores = 4)
save(resListZINB, file = "RCMsim/resListZINBOA.RData")
 } else {load("RCMsim/resListZINBOA.RData")}
  
IDlistZINB = lapply(datListZINB, function(x){
  id = apply(x$IDsampled, 2, unique)
  taxa = apply(id, 2, function(y){rownames(x$rhosSampled)[y]})
  })
resListZINBRows = lapply(resListZINB, extractRows)
resListZINBCols = mapply(resListZINB, resListZINBRows, FUN = extractCols, SIMPLIFY = FALSE)

datListZINB = lapply(RCMresListZINB, function(x){x$X})
SilDFZINB = makeSilDf(resListZINBRows, groupFactorZINB)
CorDFZINBlib = makeCorDf(resListZINBRows, datListZINB, scoreDim = "rows", groupMeth = groupsMeth)
CorDFZINBtax = makeCorDf(resListZINBCols, datListZINB, scoreDim = "columns", groupMeth = groupsMeth)
distDFZINB = makeDistDf(resListZINBRows, groupFactorZINB)
contrZINB = contrTaxaWrap(resListZINBRows, resListZINBCols, IDlistZINB, groupFactorZINB)
rm(resListZINBRows, resListZINB, datListZINB, resListZINBCols);gc(verbose = FALSE)
save(CorDFZINBlib, CorDFZINBtax, SilDFZINB, distDFZINB, contrZINB, file = "RCMsim/resListZINB.RData")
} else {load(file = "RCMsim/resListZINB.RData")}
```

##### Dirichlet-multinomial

The use of the Dirichlet multinomial for microbiome data was proposed by La Rosa _et al._ (2012). Although it is very restrictive in terms of variance and covariance structures, we include it here because of its relative popularity. Also Chen _et al._ (2012) use it to simulate data for a visualization.

```{r simDM, purl = FALSE}
p = 1000 #Number of taxa
n = 60 #Number of samples
nPop = 4 #Number of underlying populations
nPerPop = n/nPop #Number of samples per population
reps = 100 #replicates
nDim  = 3 #Number of dimensions
TPR = 0.1
FC = 5

groupInd = rep(1:nPop, each = nPerPop) #Group indicator, as integers
groupFactorDM = factor(groupInd, levels = 1:nPop, labels =  paste("Population", 1:nPop), ordered = TRUE) #as factor
load("/home/stijn/PhD/American Gut/AGdm.RData")

if(!file.exists(file = "RCMsim/datListDM.RData")){
  require(HMP)
datListDM = mclapply(mc.cores = 1, 1:reps, function(i){
## Sample parameters
rhosSampled0 = sample(rhoEst, p)
rhosSampled0 = rhosSampled0/sum(rhosSampled0)
#For each population, modify a fraction TPR of the abundances (compensation is not so badly needed here, we do not test individual species). Record the taxa that have been modified.
rhosIDSampled = lapply(1:nPop, function(x, rhos){
  id = sample(seq_len(p), round(TPR*p))
  rhos[id] = rhos[id]*FC
  cbind(rhos = rhos/sum(rhos), id = id) #renormalize
}, rhos = rhosSampled0)

rhosSampled00 = sapply(rhosIDSampled, function(x){x[, "rhos"]})
rhosSampled = rhosSampled00[,groupInd]
IDsampled = sapply(rhosIDSampled, function(x){x[, "id"]})

thetaDM = AGdm$theta
libSizesSampled = sample(libSizesEst, n) #Sampled libSizes

## Create dataset
dataMat = t(sapply(seq_along(libSizesSampled),function(i){Dirichlet.multinomial(libSizesSampled[i], shape = rhosSampled[,i]*(1-thetaDM)/thetaDM)}))
colnames(dataMat) = rownames(rhosSampled) 
rownames(dataMat) = groupFactorDM
rowID = rowSums(dataMat)>0
colID = colSums(dataMat)>0
dataMat = dataMat[rowID, colID]
list(dataMat = dataMat, libSizesSampled = libSizesSampled[rowID], rhosSampled = rhosSampled00[colID,], IDsampled = IDsampled[colID,])
})
save(datListDM, groupFactorDM, file = "RCMsim/datListDM.RData")
} else {load(file = "RCMsim/datListDM.RData")}

# Results
if(!file.exists(file = "RCMsim/resListDM.RData")){
  if(!file.exists("RCMsim/resListDMRCM.RData")){
# RCMresListDM = lapply(list.files("RCMsim/datListDM"), function(x){load(file.path("RCMsim/datListDM",x));tmp})
# gommResListDM = lapply(list.files("RCMsim/gomms/datListDM"), function(x){load(file.path("RCMsim/gomms/datListDM",x));tmp})
RCMresListDM = mclapply(mc.cores=4, datListDM, function(y){
  RCM(y$dataMat, k = nDim, distribution = "NB")
  })
gommResListDM = mclapply(mc.cores=4, datListDM, function(y){
  gommsPhy(y$dataMat)
  })
save(RCMresListDM, gommResListDM, file = "RCMsim/resListDMRCM.RData")
  } else {load("RCMsim/resListDMRCM.RData")}
listID = sapply(RCMresListDM, class)=="RCM"
RCMresListDM = Filter(RCMresListDM, f = is.list)

 if(!file.exists("RCMsim/resListDMOA.RData")){
resListDM = otherAnalyses(RCMresListDM, gommResListDM, cores = 4)
save(resListDM, file = "RCMsim/resListDMOA.RData")
} else {load("RCMsim/resListDMOA.RData")}

IDlistDM = lapply( datListDM[listID], function(x){
  id = apply(x$IDsampled, 2, unique)
  taxa = apply(id, 2, function(y){rownames(x$rhosSampled)[y]})
  })
resListDMRows = lapply(resListDM, extractRows)
resListDMCols = mapply(resListDM, resListDMRows, FUN=extractCols, SIMPLIFY=FALSE)

datListDM = lapply(RCMresListDM, function(x){x$X})
SilDFDM = makeSilDf(resListDMRows, groupFactorDM)
CorDFDMlib = makeCorDf(resListDMRows, datListDM, scoreDim = "rows", groupMeth = groupsMeth)
CorDFDMtax = makeCorDf(resListDMCols, datListDM, scoreDim = "columns", groupMeth = groupsMeth)
distDFDM = makeDistDf(resListDMRows, groupFactorDM)
contrDM = contrTaxaWrap(resListDMRows, resListDMCols, IDlistDM, groupFactorDM)
rm(resListDMRows, resListDM, datListDM, resListDMCols);gc(verbose = FALSE)
save(CorDFDMlib, CorDFDMtax, SilDFDM, distDFDM, contrDM, file = "RCMsim/resListDM.RData")
} else {load(file = "RCMsim/resListDM.RData")}
```

### Nonparametric simulation

An objective simulation approach would be to use non-parametric resampling from a true dataset, as in _SimSeq_. For this we need microbiome datasets with covariates known to be related to bacterial abundance, preferably with more than two groups. The Zeller data is one such dataset, with the cancer variable expected to be related to relative abundance and having three levels (Normal, small adenoma and cancer). For the American Gut data we can use IBD. For the Turnbaugh lean and obese twins dataset we can use health status (lean, overweight or obese), even though we have only 18 samples. For the Turnbaugh humanized mouse dataset we could use "Diet", with levels "BK" and "Western".

We generate data as follows

1. Select a covariate and test for differential abundance using WMW/Kruskal-Wallis
2. Calculate local false discovery rates (lfdr)
3. Sample non DA taxa with equal weights from all taxa
4. Sample DA taxa from all taxa with weights equal to 1-lfdr
5. Sample counts from non DA taxa from samples with the most frequent covariate level
6. Sample counts from DA taxa also from the samples with other covariate levels, and correct for differences in library sizes. This maintains the same distribution of covariate levels and overal data matrix size as the original dataset. 

```{r simSeqAnalysis, purl = FALSE}
if(!file.exists("RCMsim/resListSimSeq.RData")){
    if(!file.exists(file = "SimSeqTests.RData")){

load(file = "/home/stijn/PhD/Datasets/Humanized mouse/HumMicePhy.RData")
testHum = testSimSeq(HumMicePhy, "Diet")
load(file = "/home/stijn/PhD/Datasets/TurnbaughObeseTwins/TurnTwins.RData")
testTwins = testSimSeq(TurnTwins, "Status_p") # No significance
testAG = testSimSeq(AGphylo, "IBD")
load("/home/stijn/PhD/Simulations/data/zellerData.RData")
testZeller = testSimSeq(zellerSphy, "Diagnosis")
load("/home/stijn/PhD/Biplots/Kostic.RData")
testKostic = testSimSeq(kostic, "TREATMENT")
load(file = "/home/stijn/PhD/Biplots/CMETdata.RData")
testCMETphase = testSimSeq(CMETwater, "Reactor.phase")
testCMETcycle = testSimSeq(CMETwater, "Reactor.cycle")
save(testHum, testTwins, testAG, testZeller, testKostic, testCMETphase, testCMETcycle, file = "SimSeqTests.RData")
} else {load(file = "SimSeqTests.RData")}
  
  if(!file.exists(file = "SimSeqData.RData")){
NsimSimSeq = 100
HumSimSeqList = mclapply(mc.cores = 1, 1:NsimSimSeq, function(i){
  genSimSeq(testHum)
})
AGSimSeqList = mclapply(mc.cores = 1, 1:NsimSimSeq, function(i){
  genSimSeq(testAG)
})
ZellerSimSeqList = mclapply(mc.cores = 1, 1:NsimSimSeq, function(i){
  genSimSeq(testZeller)
})
KosticSimSeqList = mclapply(mc.cores = 1, 1:NsimSimSeq, function(i){
  genSimSeq(testKostic, fracTaxa = 0.125)
})
CMETphaseSimSeqList = mclapply(mc.cores = 1, 1:NsimSimSeq, function(i){
  genSimSeq(testCMETphase)
})
CMETcycleSimSeqList = mclapply(mc.cores = 1, 1:NsimSimSeq, function(i){
  genSimSeq(testCMETcycle)
})
save(HumSimSeqList, ZellerSimSeqList, AGSimSeqList, KosticSimSeqList, CMETphaseSimSeqList, CMETcycleSimSeqList, file = "SimSeqData.RData")
  } else {load(file = "SimSeqData.RData")}

if(!file.exists("RCMsim/resListSimSeqRCM.RData")){
RCMresListSimSeqHum = mclapply(mc.cores=4, HumSimSeqList, function(y){
  RCM(y$data, k = nDim, distribution = "NB")
  })
RCMresListSimSeqAG = mclapply(mc.cores=4, AGSimSeqList, function(y){
  RCM(y$data, k = nDim, distribution = "NB")
  })
RCMresListSimSeqZeller = mclapply(mc.cores=4, ZellerSimSeqList, function(y){
  RCM(y$data, k = nDim, distribution = "NB", round = TRUE)
  })
RCMresListSimSeqKostic = mclapply(mc.cores=4, KosticSimSeqList, function(y){
  RCM(y$data, k = nDim, distribution = "NB", round = TRUE)
  })
RCMresListSimSeqCMETphase = mclapply(mc.cores=4, CMETphaseSimSeqList, function(y){
  RCM(y$data, k = nDim, distribution = "NB", round = TRUE)
  })
RCMresListSimSeqCMETcycle = mclapply(mc.cores=4, CMETcycleSimSeqList, function(y){
  RCM(y$data, k = nDim, distribution = "NB", round = TRUE)
  })
save(RCMresListSimSeqHum, RCMresListSimSeqAG, RCMresListSimSeqZeller, file = "RCMsim/resListSimSeqRCM.RData")
} else {load("RCMsim/resListSimSeqRCM.RData")}

resListSimSeqHum = otherAnalyses(RCMresListSimSeqHum, cores = 4)

 if(!file.exists("RCMsim/resListSimSeqHumOA.RData")){
resListSimSeqHum = otherAnalyses(RCMresListSimSeqHum, cores = 4)
save(resListSimSeqHum, file = "RCMsim/resListSimSeqHumOA.RData")
} else {load("RCMsim/resListSimSeqHumOA.RData")}

rm(RCMresListSimSeqHum);gc(verbose = FALSE)
IDlistHum = mapply(HumSimSeqList,resListSimSeqHum, FUN =  function(y,x, test){
    taxa = y$DEtaxa[y$DEtaxa %in% colnames(x$RCM$X)]
    test[taxa,]
    }, SIMPLIFY = FALSE, MoreArgs = list(test = t(testHum$result)))
groupFactorHum = HumSimSeqList[[1]]$treatment
resListSimSeqHumRows = lapply(resListSimSeqHum, extractRows)
resListSimSeqHumCols = mapply(resListSimSeqHum, resListSimSeqHumRows, FUN=extractCols, SIMPLIFY=FALSE)

datListHum = lapply(RCMresListSimSeqHum, function(x){x$X})
SilDFHum = makeSilDf(resListSimSeqHumRows, groupFactorHum)
CorDFHumlib = makeCorDf(resListSimSeqHumRows, datListHum, scoreDim = "rows", groupMeth = groupsMeth)
CorDFHumtax = makeCorDf(resListSimSeqHumCols, datListHum, scoreDim = "columns", groupMeth = groupsMeth)
distDFHum = makeDistDf(resListSimSeqHumRows, groupFactorHum)
contrHum = contrTaxaWrap(resListSimSeqHumRows, resListSimSeqHumCols, IDlistHum, groupFactorHum, upDown = TRUE)
rm(resListSimSeqHumRows, resListHum, datListHum, resListSimSeqHumCols);gc(verbose = FALSE)

# Zeller
zellerID = sapply(RCMresListSimSeqZeller, class) == "RCM"
resListSimSeqZeller = otherAnalyses(RCMresListSimSeqZeller[zellerID], cores = 4)

 if(!file.exists("RCMsim/resListSimSeqZellerOA.RData")){
resListSimSeqZeller = otherAnalyses(RCMresListSimSeqZeller[zellerID], cores = 4)
save(resListSimSeqZeller, file = "RCMsim/resListSimSeqZellerOA.RData")
} else {load("RCMsim/resListSimSeqZellerOA.RData")}

IDlistZeller = mapply(ZellerSimSeqList[zellerID],RCMresListSimSeqZeller[zellerID], FUN =  function(y,x, test){
    taxa = y$DEtaxa[y$DEtaxa %in% colnames(x$X)]
    test[taxa,]
    }, SIMPLIFY = FALSE, MoreArgs = list(test = t(testZeller$result)))
groupFactorZeller = ZellerSimSeqList[[1]]$treatment
resListSimSeqZellerRows = lapply(resListSimSeqZeller, extractRows)
resListSimSeqZellerCols = mapply(resListSimSeqZeller, resListSimSeqZellerRows, FUN=extractCols, SIMPLIFY=FALSE)
datListZeller = lapply(RCMresListSimSeqZeller[zellerID], function(x){x$X})
SilDFZeller = makeSilDf(resListSimSeqZellerRows, groupFactorZeller)
CorDFZellerlib = makeCorDf(resListSimSeqZellerRows, datListZeller, scoreDim = "rows", groupMeth = groupsMeth)
CorDFZellertax = makeCorDf(resListSimSeqZellerCols, datListZeller, scoreDim = "columns", groupMeth = groupsMeth)
distDFZeller = makeDistDf(resListSimSeqZellerRows, groupFactorZeller)
contrZeller = contrTaxaWrap(resListSimSeqZellerRows, resListSimSeqZellerCols, IDlistZeller, groupFactorZeller, upDown = TRUE)
rm(resListSimSeqZellerRows, resListZeller, datListZeller, resListSimSeqZellerCols);gc(verbose = FALSE)

save(SilDFHum, CorDFHumlib, CorDFHumtax, distDFHum, contrHum, SilDFZeller, CorDFZellerlib, CorDFZellertax, distDFZeller, contrZeller, file = "RCMsim/resListSimSeq.RData")
} else {load("RCMsim/resListSimSeq.RData")}
```

# Method evaluation

After implementing the method and proving its concept, it is time to compare it with existing methodologies. We need to define a way to obtain datasets, and a way to evaluate the ordinations in a high-throughput way. For the simulation we will need multiple repetitions to prove the superiority of our method, so we need an automatic evaluation of the clustering accuracy.

## Overall vs. within distance

A first intuitive approach would be to compare the within cluster distances on the plot to the distances to the origin. Clusters are defined as samples generated with the same taxon distribution, either parametrically or non-parametrically. Say we have $m = 1,...,l$ groups with (multidimensional) means $\mathbf{M}_m$.  The within distance is then defined as $d_{m, within} = \frac{1}{n_m}\sum_{i=1}^{n_m} d_{euclidean}(\mathbf{M}_m, Y_i)$, with $d_{euclidean}$ the euclidean distance. The overall distance of a group then equals $d_{m, overall} = \frac{1}{n_m}\sum_{i=1}^{n_m} d_{euclidean}(\mathbf{0}, Y_i)$ with $\mathbf{0}$ the origin. This calculation can be done for each dimension separately or in the multidimensional space.

We could perhaps look for the distance based method that maximizes $\frac{d_{m, overall}}{d_{m, within}}$? This is related to Ward's minimum variance method, but with scaling to the overall distance. This takes differences in the scales of solutions of different methods into account. We then use the geometric mean of these ratios over the different clusters as statistic:

$$\Big(\prod_{m=1}^l\frac{d_{m, overall}}{d_{m, within}}\Big)^{1/l}$$

This approach can only be applied to the row scores (samples), since there the importance parameters are multiplied and thus distances are represented correctly. This approach is reminiscent of Ward clustering \cite{Ward1963} and a pseudo F-statistic \cite{Anderson2001}.

## Silhouette

See "Silhouettes: a Graphical Aid to the Interpretation and Validation of Cluster Analysis", Rousseeuw, 1987. The silhouette can be calculated with any distance measure, but we will just use the euclidean distance again. For each point $i$, calculate the distance to each other point in the ordination, and average these distances within the cluster. Call $a(i)$ the average distance to its own cluster and $b(i)$ the smallest of the average distances to the other cluster. The the silhouette of observation i $s(i)$ is defined as:

$$s(i) = \frac{b(i) - a(i)}{max\big(a(i), b(i)\big)}$$

The silhouette can take values between +1 for optimal separation and -1 for wrong classification. If a poin i close to the centroid of its own cluster but very far from all the others the methods has performed well and is rewarded with a high silhouette. We can average the silhouttes over the ordination or jus look at their distribution to compare the ordination methods.

## Correlation with library sizes and abundances

The motivating problem to develop the whole method was to find an approach that would not show correlation between the row scores and the library sizes, which is a technical artefact.

Pearson correlations of row scores with library sizes could be another criterion to evaluate the quality of the biplot. Equivalently correlations with average relative abundance can be investigated.

## Contribution of taxa to the separation of the clusters

For the methods that do yield taxon scores, we can also verify if the correct taxa contribute to the separation of the clusters. A useful measure in this case seems the relative contribution of the taxa with signal in the direction of the cluster centroid, compared to the non-signal taxa. 

With $\mathbf{H}_l$ the vector from the origin to the sample centroid of group $l$, $\mathbf{s}_{l,sig}$ the $n_{l,sig}$-by-k matrix with scores of the $n_{l,sig}$ taxa in group l with signal and $\mathbf{s}_{l,noSig}$ the $n_{l,noSig}$-by-k matrix with scores of the $n_{l,noSig}$ taxa without signal, the quantity we are looking for is:

$$ \frac{n_{l,noSig} \mathbf{s}_{l,sig}\mathbf{H}_l \mathbb{1}}{n_{l,sig} \mathbf{s}_{l,noSig}\mathbf{H}_l \mathbb{1}}$$

with $\mathbb{1}$ a column matrix of one of the appropriate dimension. However, this will very often lead to negative and/or very large ratios. Therefore we look at the average ratio of the median signal of the signal taxa to the 75th percentile of the signal of the non-signal taxa. The rationale is that half of the non-signal taxa are expected to contribute in the direction of the cluster, and taking the median of this half is in practice the 75th percentile. The final statistic is thus


$$\frac{1}{m}\sum_{l=1}^m \frac{\underset{j}{\mathrm{median}} (\mathbf{s}_{lj,sig}\mathbf{H}_l )}{\underset{j}{\hat{F}^{-1}_{0.75}}(\mathbf{s}_{lj,noSig}\mathbf{H}_l )}$$

# Simulation results

## Correlations with library sizes

Library sizes are considered to be technical artefacts, and thus should not affect the ordination, which is meant to display only biological signal. To verify this we calculate the correlations of the observed library sizes with every set of sample scores and compare this with the correlation with a random standard normal variable.

### Parametric simulation

```{r libCor0, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H0 in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCor0}"}
plotCor(CorDF0lib)
```

```{r libCor0, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H0 in the first three dimensions. The library sizes were tenfold larger in half of the samples than in the other half. Orange diamonds indicate means.\\label{supfig:libCor0}"}
plotCor(CorDF0blib)
```

```{r libCor4, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H0, but with differences in dispersions between 4 sample groups, in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCor4}"}
plotCor(CorDF4lib)
```

```{r libCor1, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H1 with 4 unrelated sample groups in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCor1}"}
plotCor(CorDF1lib)
```

```{r libCor2, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCor2}"}
plotCor(CorDF2lib)
```

```{r libCor3, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and differences in library sizes in each group in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCor3}"}
plotCor(CorDF3lib)
```

```{r libCor5, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCor5}"}
plotCor(CorDF5lib)
```

```{r libCorPhy, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCorPhy}"}
plotCor(CorDFPhylib)
```

```{r libCorDM, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the Dirichlet multinomial distribution under H1 in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCorDM}"}
plotCor(CorDFDMlib)
```

```{r libCorZINB, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 simulations with the zero-inflated negative binomial distribution under H1 in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCorZINB}"}
plotCor(CorDFZINBlib)
```

\clearpage

### Non-parametric simulation

```{r libCorHum, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 non-parametric simulations based on the Turnbaugh dataset in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCorHum}"}
plotCor(CorDFHumlib)
```

```{r libCorZeller, fig.cap = "Correlations of sample scores and random standard normal control variable with library sizes, results of 100 non-parametric simulations based on the Zeller dataset in the first three dimensions. Orange diamonds indicate means.\\label{supfig:libCorZeller}"}
plotCor(CorDFZellerlib)
```

#### Correlations with library sizes in original datasets

Some methods have row scores that correlate with library sizes in non-parametric simulations but not in parametric ones. Perhaps the biological effect is confounded with the library sizes here? for this we plot the observed library sizes in function of the grouping cofactors.

```{r LibboxplotHum, fig.cap = "Observed library sizes in original dataset in function of diet in the Turnbaugh dataset\\label{supfig:boxplotHum}"}
load(file = "/home/stijn/PhD/Datasets/Humanized mouse/HumMicePhy.RData")
boxplot(sample_sums(HumMicePhy)~get_variable(physeq = HumMicePhy, "Diet"))
```

```{r LibboxplotZeller, fig.cap = "Observed library sizes in original dataset in function of diagnosis in the Zeller dataset\\label{supfig:LibboxplotZeller}"}
load("/home/stijn/PhD/Simulations/data/zellerData.RData")
boxplot(sample_sums(zellerSphy)~get_variable(physeq = zellerSphy, "Diagnosis"))
```

```{r LibboxplotZeller, fig.cap = "Observed library sizes in original dataset in function of diagnosis in the Kostic dataset\\label{supfig:LibboxplotKostic}"}
load("/home/stijn/PhD/Biplots/Kostic.RData")
boxplot(sample_sums(kostic)~get_variable(physeq = kostic, "TREATMENT"))
```

```{r LibboxplotPropsPhase, fig.cap = "Observed library sizes in original dataset in function of reactor phase in the Props dataset\\label{supfig:LibboxplotPropsPhase}"}
load(file = "/home/stijn/PhD/Biplots/CMETdata.RData")
boxplot(sample_sums(CMETwater)~get_variable(physeq = CMETwater, "Reactor.cycle"))
```

```{r LibboxplotPropsCycle, fig.cap = "Observed library sizes in original dataset in function of diagnosis in the Props dataset\\label{supfig:LibboxplotPropsCycle}"}
boxplot(sample_sums(CMETwater)~get_variable(physeq = CMETwater, "Reactor.phase"))
```

Biologically meaningful variables are clearly related to the library sizes.

\clearpage

## Correlations with dispersions

Dispersion parameters differ between taxa, but are only related to their variance, no to their mean abundance. As a result they should not affect the ordination, and thus not be correlated to the taxon scores.

```{r dispCor0, fig.cap = "Correlations of sample scores and random standard normal control variable with disprary sizes, results of 100 simulations with the negative binomial under H0 in the first three dimensions. Orange diamonds indicate means.\\label{supfig:dispCor0}"}
plotCor(CorDF0disp, scoreDim = "dispersions")
```

```{r dispCor0b, fig.cap = "Correlations of sample scores and random standard normal control variable with disprary sizes, results of 100 simulations with the negative binomial under H0 in the first three dimensions. The disprary sizes were tenfold larger in half of the samples than in the other half. Orange diamonds indicate means.\\label{supfig:dispCor0}"}
plotCor(CorDF0bdisp)
```

```{r dispCor4, fig.cap = "Correlations of sample scores and random standard normal control variable with disprary sizes, results of 100 simulations with the negative binomial under H0, but with differences in dispersions between 4 sample groups, in the first three dimensions. Orange diamonds indicate means.\\label{supfig:dispCor4}"}
plotCor(CorDF4disp)
```

```{r dispCor1, fig.cap = "Correlations of sample scores and random standard normal control variable with disprary sizes, results of 100 simulations with the negative binomial under H1 with 4 unrelated sample groups in the first three dimensions. Orange diamonds indicate means.\\label{supfig:dispCor1}"}
plotCor(CorDF1disp)
```

```{r dispCor2, fig.cap = "Correlations of sample scores and random standard normal control variable with disprary sizes, results of 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa in the first three dimensions. Orange diamonds indicate means.\\label{supfig:dispCor2}"}
plotCor(CorDF2disp)
```

```{r dispCor3, fig.cap = "Correlations of sample scores and random standard normal control variable with disprary sizes, results of 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and differences in disprary sizes in each group in the first three dimensions. Orange diamonds indicate means.\\label{supfig:dispCor3}"}
plotCor(CorDF3disp)
```

```{r dispCor5, fig.cap = "Correlations of sample scores and random standard normal control variable with disprary sizes, results of 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa in the first three dimensions. Orange diamonds indicate means.\\label{supfig:dispCor5}"}
plotCor(CorDF5disp)
```

```{r dispCorPhy, fig.cap = "Correlations of sample scores and random standard normal control variable with disprary sizes, results of 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa in the first three dimensions. Orange diamonds indicate means.\\label{supfig:dispCorPhy}"}
plotCor(CorDFPhydisp)
```

```{r dispCorDM, fig.cap = "Correlations of sample scores and random standard normal control variable with disprary sizes, results of 100 simulations with the Dirichlet multinomial distribution under H1 in the first three dimensions. Orange diamonds indicate means.\\label{supfig:dispCorDM}"}
plotCor(CorDFDMdisp)
```

```{r dispCorZINB, fig.cap = "Correlations of sample scores and random standard normal control variable with disprary sizes, results of 100 simulations with the zero-inflated negative binomial distribution under H1 in the first three dimensions. Orange diamonds indicate means.\\label{supfig:dispCorZINB}"}
plotCor(CorDFZINBdisp)
```

\clearpage

### Non-parametric simulation

```{r dispCorHum, fig.cap = "Correlations of sample scores and random standard normal control variable with disprary sizes, results of 100 non-parametric simulations based on the Turnbaugh dataset in the first three dimensions. Orange diamonds indicate means.\\label{supfig:dispCorHum}"}
plotCor(CorDFHumdisp)
```

```{r dispCorZeller, fig.cap = "Correlations of sample scores and random standard normal control variable with disprary sizes, results of 100 non-parametric simulations based on the Zeller dataset in the first three dimensions. Orange diamonds indicate means.\\label{supfig:dispCorZeller}"}
plotCor(CorDFZellerdisp)
```

## Sample separatation

### Silhouette

#### Parametric simulation without signal

```{r sil0b, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the negative binomial without signal but with differences in library sizes between the groups. Orange diamonds indicate means.\\label{supfig:sil0b}"}
plotSil(SilDF0b)
```

```{r sil4, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the negative binomial without signal but with differences in dispersions between the groups. Orange diamonds indicate means.\\label{supfig:sil4}"}
plotSil(SilDF4)
```

#### Parametric simulation with signal

```{r sil1, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 unrelated sample groups. Orange diamonds indicate means.\\label{supfig:sil1}"}
plotSil(SilDF1)
```

```{r sil2, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:sil2}"}
plotSil(SilDF2)
```

```{r sil3, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and differences in library sizes in each group. Orange diamonds indicate means.\\label{supfig:sil3}"}
plotSil(SilDF3)
```

```{r sil5, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa. Orange diamonds indicate means.\\label{supfig:sil5}"}
plotSil(SilDF5)
```

```{r silPhy, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa. Orange diamonds indicate means.\\label{supfig:silPhy}"}
plotSil(SilDFPhy)
```

```{r silDM, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the Dirichlet multinomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:silDM}"}
plotSil(SilDFDM)
```

```{r silZINB, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 simulations with the zero-inflated negative binomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:silZINB}"}
plotSil(SilDFZINB)
```

\clearpage

#### Non-parametric simulation

```{r silHum, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 non-parametric simulations based on the Turnbaugh data. Orange diamonds indicate means.\\label{supfig:silHum}"}
plotSil(SilDFHum)
```

```{r silZeller, fig.cap = "Boxplots of silhouettes in the first three dimensions by ordination method for 100 non-parametric simulations based on the Zeller data. Orange diamonds indicate means.\\label{supfig:silZeller}"}
plotSil(SilDFZeller)
```

\clearpage

### Between-overall distance ratio

#### Parametric simulation without signal

```{r dist0b, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the negative binomial without signal but with differences in library sizes between the groups. Orange diamonds indicate means.\\label{supfig:dist0b}"}
distRatioPlot(distDF0b)
```

```{r dist4, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the negative binomial without signal but with differences in dispersions between the groups. Orange diamonds indicate means.\\label{supfig:dist4}"}
distRatioPlot(distDF4)
```

#### Parametric simulation with signal

```{r dist1, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 unrelated sample groups. Orange diamonds indicate means.\\label{supfig:dist1}"}
distRatioPlot(distDF1)
```

```{r dist2, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:dist2}"}
distRatioPlot(distDF2)
```

```{r dist3, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and differences in library sizes in each group. Orange diamonds indicate means.\\label{supfig:dist3}"}
distRatioPlot(distDF3)
```

```{r dist5, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa. Orange diamonds indicate means.\\label{supfig:dist5}"}
distRatioPlot(distDF5)
```

```{r distPhy, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa. Orange diamonds indicate means. DPCoA and weighted Unifrac clearly profit from using the phylogenetic information\\label{supfig:distPhy}"}
distRatioPlot(distDFPhy)
```

```{r distDM, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the Dirichlet multinomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:distDM}"}
distRatioPlot(distDFDM)
```

```{r distZINB, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 simulations with the zero-inflated negative binomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:distZINB}"}
distRatioPlot(distDFZINB)
```

\clearpage

#### Non-parametric simulation

```{r distHum, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 non-parametric simulations based on the Turnbaugh data. Orange diamonds indicate means.\\label{supfig:distHum}"}
distRatioPlot(distDFHum)
```

```{r distZeller, fig.cap = "Boxplots of between-to-overall distance ratios in the first three dimensions by ordination method for 100 non-parametric simulations based on the Zeller data. Orange diamonds indicate means.\\label{supfig:distZeller}"}
distRatioPlot(distDFZeller)
```

\clearpage

## Taxon identification

#### Parametric simulation

```{r contr2, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:contr2}"}
contrPlot(contr2)
```

```{r contr3, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and differences in library sizes in each group. Orange diamonds indicate means.\\label{supfig:contr3}"}
contrPlot(contr3)
```

```{r contr5, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa. Orange diamonds indicate means.\\label{supfig:contr5}"}
contrPlot(contr5)
```

```{r contrPhy, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 simulations with the negative binomial under H1 with 4 related sample groups with 10% DA taxa and correlated taxa. Orange diamonds indicate means. DPCoA and weighted Unifrac clearly profit from using the phylogenetic information\\label{supfig:contrPhy}"}
contrPlot(contrPhy)
```

```{r contrDM, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 simulations with the Dirichlet multinomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:contrDM}"}
contrPlot(contrDM)
```

```{r contrZINB, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 simulations with the zero-inflated negative binomial under H1 with 4 related sample groups with 10% DA taxa. Orange diamonds indicate means.\\label{supfig:contrZINB}"}
contrPlot(contrZINB)
```

\clearpage

#### Non-parametric simulation

```{r contrHum, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 non-parametric simulations based on the Turnbaugh data. Orange diamonds indicate means.\\label{supfig:contrHum}"}
contrPlot(contrHum)
```

```{r contrZeller, fig.cap = "Boxplots of ratios of DA taxa and NDA taxa contributions to separations of the clusters in the first three dimensions by ordination method for 100 non-parametric simulations based on the Zeller data. Orange diamonds indicate means.\\label{supfig:contrZeller}", eval = FALSE}
contrPlot(contrZeller)
```